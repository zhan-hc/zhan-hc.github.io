<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笨鸟</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-21T16:51:50.071Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HC-ZHAN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js-原型-原型链</title>
    <link href="http://example.com/2020/12/21/js-prototype/"/>
    <id>http://example.com/2020/12/21/js-prototype/</id>
    <published>2020-12-21T15:51:09.000Z</published>
    <updated>2020-12-21T16:51:50.071Z</updated>
    
    <content type="html"><![CDATA[<ul><li>构造函数</li><li>原型</li><li>原型链</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>通过 <font color='red'>new</font> 函数名来实例化对象的函数叫构造函数。任何的函数都可以作为构造函数存在。<br>之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要 功能为 初始化对象，特点是和new 一起使用。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">&#x27;孙悟空&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong><font color='red'>f1</font>就是一个构造函数</strong></p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<font color='red'>prototype</font>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。<br>对象具有属性<font color='red'><strong>proto</strong></font>，可称为隐式原型，一个对象的隐式原型指向<font color='red'>构造该对象的构造函数的原型</font>，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f1.__proto__ === Foo.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>方法（<font color='red'>Function</font>）方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（<font color='red'>prototype</font>），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做<font color='red'>constructor</font>，这个属性包含了一个指针，指回原构造函数。</strong></p><ul><li><strong>每个构造函数都有一个prototype原型对象</strong></li><li><strong>prototype原型对象里的constructor指向构造函数本身</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="prototype.jpg" alt="prototype"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们来分析一下上图</p><blockquote><p><strong>1.构造函数Foo()<br>构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。</strong><br><strong>2.原型对象Foo.prototype<br>Foo.prototype保存着实例共享的方法，有一个指针<font color='red'>constructor</font>指回构造函数。</strong><br><strong>3.实例<br><font color='red'>f1和f2</font>是Foo这个对象的两个实例，这两个对象也有属性<font color='red'><strong>proto</strong></font>，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</strong></p></blockquote><p><strong>另外：<br>构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？<br>指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。</strong></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</strong></p><p>举例说明: f1 → Foo → Object ，foo继承Foo，Foo继承Object</p><p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</strong><br><strong><font color='red'>Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有__proto__这个属性。</font></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>大部分参考作者doris的内容，具体可看作者doris<a href="https://www.zhihu.com/question/34183746/answer/58155878">知乎文章</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;原型&lt;/li&gt;
&lt;li&gt;原型链&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;通过 &lt;</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="prototype" scheme="http://example.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>CSS 盒模型</title>
    <link href="http://example.com/2020/12/18/css-box/"/>
    <id>http://example.com/2020/12/18/css-box/</id>
    <published>2020-12-18T11:42:05.000Z</published>
    <updated>2020-12-18T12:43:58.472Z</updated>
    
    <content type="html"><![CDATA[<p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><ul><li>W3C标准盒模型</li><li>IE盒模型</li><li>两种盒模型的区别</li></ul><p>盒子模型<br><img src="box-model.png" alt="盒子模型"></p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong>- 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h2 id="W3C标准盒模型"><a href="#W3C标准盒模型" class="headerlink" title="W3C标准盒模型"></a>W3C标准盒模型</h2><p><img src="test2.jpg" alt="标准盒模型"><br><font color='red'><strong>盒子的内容区域(content) = 设置的width/height</strong></font><br><strong>标准盒模型的宽高</strong><br><font color='red'><strong>width=  content + padding * 2 + border * 2<br>height=  content + padding * 2 + border * 2</strong></font></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#87CEFA</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid<span class="number">#FFA07A</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="test.PNG" alt="标准盒模型"><br>我们点击f12，打开调试页面<br><img src="test1.PNG" alt="标准盒模型"><br>明明我们设置的是宽高为300x200的盒子，发现却是一个360x260的盒子。<br>盒子的宽高：<br><strong>360(width) = 300(content) + 20(padding) * 2 + 10(border) * 2</strong><br><strong>260(height) = 200(content) + 20(padding) * 2 + 10(border) * 2</strong></p><h2 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h2><p><img src="test3.jpg" alt="IE盒模型"><br><font color='red'><strong>盒子的宽高 = 设置的width/height</strong></font></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#FFA07A</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="number">#87CEFA</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    box-sizing: border-box; // 改变盒模型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="test5.PNG" alt="IE盒模型"><br>我们点击f12，打开调试页面<br><img src="test4.PNG" alt="IE盒模型"></p><p>盒子的宽高：<br><strong>300(width) = 240(content) + 20(padding) * 2 + 10(border) * 2</strong><br><strong>200(height) = 140(content) + 20(padding) * 2 + 10(border) * 2</strong></p><h2 id="两种盒模型的区别"><a href="#两种盒模型的区别" class="headerlink" title="两种盒模型的区别"></a>两种盒模型的区别</h2><ul><li>在 标准盒子模型中，width 和 height 指的是<strong>内容区域的宽度和高度</strong>。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li>IE盒子模型中，width 和 height 指的是<strong>内容区域</strong>+<strong>border</strong>+<strong>padding</strong>的宽度和高度。</li></ul><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>如果想要切换盒模型也很简单，这里需要借助css3的box-sizing属性</p><blockquote><ul><li><strong>box-sizing: content-box</strong> 是W3C盒模型</li><li><strong>box-sizing: border-box</strong> 是IE盒模型</li></ul></blockquote><p><strong>box-sizing的默认属性是content-box</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。&lt;br&gt;CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。&lt;br&gt;盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js的执行机制</title>
    <link href="http://example.com/2020/12/15/js-Event-Loop/"/>
    <id>http://example.com/2020/12/15/js-Event-Loop/</id>
    <published>2020-12-15T15:46:41.000Z</published>
    <updated>2020-12-21T16:52:22.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h1><h2 id="为什么js是单线程？"><a href="#为什么js是单线程？" class="headerlink" title="为什么js是单线程？"></a>为什么js是单线程？</h2><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h2 id="为什么要有事件循环？"><a href="#为什么要有事件循环？" class="headerlink" title="为什么要有事件循环？"></a>为什么要有事件循环？</h2><p>因为Javascript在浏览器中是单线程，所以在进行一个延时操作时并不能真的就让进程在原地等待那么久，那样用户的相关操作就“卡死”在哪里了，所以引入了事件循环的机制来，将需要消耗时间的操作“跳过去”，等主线程的操作完成了，再检查任务队列中是否还有任务，然后将任务调出来执行。就这样反复循环执行，所以就叫做事件循环。<br><img src="event.png" alt="Event Loop"><br>导图表达的内容：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;发送成功!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入<strong>Event Table</strong>，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入<strong>Event Queue</strong>。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p><h2 id="事件循环中的setTimeout"><a href="#事件循环中的setTimeout" class="headerlink" title="事件循环中的setTimeout"></a>事件循环中的setTimeout</h2><p>大家对他的第一印象就是<strong>异步</strong>可以延时执行，我们经常这么实现延时3秒执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;延时3秒&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？<br>先看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;执行console&#x27;</span>);</span><br></pre></td></tr></table></figure><p>根据前面我们的结论，setTimeout是<strong>异步</strong>的，应该先执行console.log这个同步任务，所以我们的结论是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行console</span></span><br><span class="line"><span class="comment">//task()</span></span><br></pre></td></tr></table></figure><p>去验证一下，结果正确！<br>然后我们修改一下前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">sleep(<span class="number">10000000</span>)</span><br></pre></td></tr></table></figure><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？<br>这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：</p><ul><li><font color='red'><strong>task()</strong></font>进入Event Table并注册,计时开始。</li><li>执行<font color='red'><strong>sleep</strong></font>函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件<font color='red'><strong>timeout</strong></font>完成，<font color='red'><strong>task()</strong></font>进入<strong>Event Queue</strong>，但是<font color='red'><strong>sleep</strong></font>也太慢了吧，还没执行完，只好等着。</li><li><font color='red'><strong>sleep</strong></font>终于执行完了，<font color='red'><strong>task()</strong></font>终于从<strong>Event Queue</strong>进入了主线程执行。</li></ul><p>上述的流程走完，我们知道<font color='red'><strong>setTimeout</strong></font>这个函数，是经过指定时间后，把要执行的任务(本例中为<font color='red'><strong>task()</strong></font>)加入到<strong>Event Queue</strong>中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><h3 id="setTimeout-fn-0-示例"><a href="#setTimeout-fn-0-示例" class="headerlink" title="setTimeout(fn,0)示例"></a>setTimeout(fn,0)示例</h3><p>我们还经常遇到 <strong>setTimeout(fn,0)</strong> 这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？<br>答案是不会的，<strong>setTimeout(fn,0)</strong> 的含义是：<strong>指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。</strong><br>举例说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>结果：a d c b</strong></p><ul><li> <strong>console.log(‘a’)</strong> 和 <strong>console.log(‘d’)</strong> 进入主线程</li><li> 定时器 <strong>setTimeout</strong> 延迟一段时间执行，顾名思义异步任务进入<strong>Event Queue</strong>中，等待主线程任务执行完毕，再进入主线程执行。</li></ul><p>有人疑惑为什么<strong>c</strong>比<strong>b</strong>先输出？<br><strong>定时器的延迟时间为 0 并不是立刻执行，只是代表相比于其他定时器更早的进入主线程中执行。即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</strong><br>如果宏任务里的settimeout延迟时间不一样，优先执行短的，等短的settimeout整个宏任务执行完了才到长的settimeout<br>因为<strong>c</strong>的延迟时间比<strong>b</strong>短，所以更早进入主线程。</p><h2 id="事件循环中的setInterval"><a href="#事件循环中的setInterval" class="headerlink" title="事件循环中的setInterval"></a>事件循环中的setInterval</h2><p><font color='red'><strong>setTimeout</strong></font> 的孪生兄弟 <font color='red'><strong>setInterval</strong></font>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<font color='red'><strong>setInterval</strong></font> 会每隔指定的时间将注册的函数置入<strong>Event Queue</strong>，如果前面的任务耗时太久，那么同样需要等待。<br>唯一需要注意的一点是，对于 <font color='red'><strong>setInterval(fn,ms)</strong></font> 来说，我们已经知道 <strong>不是</strong> 每过ms秒会执行一次fn，而是每过ms秒，会有fn进入 <strong>Event Queue</strong> 。<br><strong>一旦 <font color='red'>setInterval</font> 的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</strong></p><h2 id="事件循环中的Promise与process-nextTick-callback"><a href="#事件循环中的Promise与process-nextTick-callback" class="headerlink" title="事件循环中的Promise与process.nextTick(callback)"></a>事件循环中的Promise与process.nextTick(callback)</h2><p>除了广义的<strong>同步</strong>任务和<strong>异步</strong>任务，我们对任务有更精细的定义：</p><ul><li><font color='red'><strong>macro-task(宏任务)</strong></font>  ：包括<strong>整体代码script，setTimeout，setInterval</strong></li><li><font color='red'><strong>micro-task(微任务)</strong></font> ：<strong>Promise，process.nextTick</strong></li></ul><p>不同类型的任务会进入对应的<strong>Event Queue</strong>，比如<strong>setTimeout</strong>和<strong>setInterval</strong>会进入相同的<strong>Event Queue</strong>。</p><p><strong>事件循环的顺序，决定js代码的执行顺序。</strong>进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。<br>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;console&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<strong>setTimeout</strong>，那么将其回调函数注册后分发到宏任务<strong>Event Queue</strong>。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<strong>Promise</strong>，<strong>new Promise</strong>立即执行，<strong>then</strong>函数分发到微任务<strong>Event Queue</strong>。</li><li>遇到console.log()，立即执行。</li><li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 <strong>then</strong> 在微任务 <strong>Event Queue</strong> 里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 <strong>Event Queue</strong> 开始。我们发现了宏任务 <strong>Event Queue</strong> 中 <strong>setTimeout</strong> 对应的回调函数，立即执行。</li><li>结束。</li></ul><p>事件循环，宏任务，微任务的关系如图所示：<br><img src="mask.png" alt="mask"></p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>分析一段复杂代码验收成果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第一轮事件循环流程分析如下："><a href="#第一轮事件循环流程分析如下：" class="headerlink" title="第一轮事件循环流程分析如下："></a>第一轮事件循环流程分析如下：</h3><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到 <font color='red'><strong>setTimeout</strong></font> ，其回调函数被分发到宏任务<strong>Event Queue</strong>中。我们暂且记为<font color='red'><strong>setTimeout1</strong></font> 。</li><li>遇到 <font color='red'><strong>process.nextTick()</strong></font> ，其回调函数被分发到微任务<strong>Event Queue</strong>中。我们记为<font color='red'><strong>process1</strong></font> 。</li><li>遇到 <font color='red'><strong>Promise</strong></font>，<font color='red'><strong>new Promise</strong></font>直接执行，输出7。<font color='red'><strong>then1</strong></font>被分发到微任务<strong>Event Queue</strong>中。我们记为<font color='red'><strong>then1</strong></font> 。</li><li>又遇到了 <font color='red'><strong>setTimeout</strong></font> ，其回调函数被分发到宏任务Event Queue中，我们记为<font color='red'><strong>setTimeout2</strong></font> 。</li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout1</td><td align="center">process1</td></tr><tr><td align="center">setTimeout2</td><td align="center">then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各<strong>Event Queue</strong>的情况，此时已经输出了1和7。</li><li>我们发现了 <font color='red'><strong>process1</strong></font> 和 <font color='red'><strong>then1</strong></font> 两个微任务。</li><li>执行 <font color='red'><strong>process1</strong></font>,输出6。</li><li>执行 <font color='red'><strong>then1</strong></font>，输出8。<br>第一轮事件循环正式结束，结果是输出<strong>1，7，6，8</strong>。</li></ul><h3 id="第二轮事件循环流程分析如下："><a href="#第二轮事件循环流程分析如下：" class="headerlink" title="第二轮事件循环流程分析如下："></a>第二轮事件循环流程分析如下：</h3><p><strong>循环从setTimeout1宏任务开始</strong></p><ul><li>首先输出2。接下来遇到了 <font color='red'><strong>process.nextTick()</strong></font> ，同样将其分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>process2</strong></font> 。<font color='red'><strong>new Promise</strong></font> 立即执行输出4，then也分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>then2</strong></font> 。</li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout2</td><td align="center">process2</td></tr><tr><td align="center"></td><td align="center">then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有<font color='red'><strong>process2</strong></font>和<font color='red'><strong>then2</strong></font>两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，<br>第二轮输出<strong>2，4，3，5</strong>。</li></ul><h3 id="第三轮事件循环流程分析如下："><a href="#第三轮事件循环流程分析如下：" class="headerlink" title="第三轮事件循环流程分析如下："></a>第三轮事件循环流程分析如下：</h3><ul><li><p>此时只剩<font color='red'><strong>setTimeout2</strong></font>了，执行。</p></li><li><p>直接输出9。</p></li><li><p>将 <font color='red'><strong>process.nextTick()</strong></font>分发到微任务<strong>Event Queue</strong>中。记为<font color='red'><strong>process3</strong></font>。</p></li><li><p>直接执行 <font color='red'><strong>new Promise</strong></font>，输出11。</p></li><li><p>将then分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>then3</strong></font>。</p><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center"></td><td align="center">process3</td></tr><tr><td align="center"></td><td align="center">then3</td></tr></tbody></table></li><li><p>第三轮事件循环宏任务执行结束，执行两个微任务<font color='red'><strong>process3</strong></font>和<font color='red'><strong>then3</strong></font>。</p></li><li><p>输出10。</p></li><li><p>输出12。</p></li><li><p>第三轮事件循环结束，</p></li></ul><p>第三轮输出<strong>9，11，10，12</strong>。</p><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><p><strong>大部分转载作者-ssssyoki的内容，具体可看作者-ssssyoki<a href="https://juejin.cn/post/6844903512845860872#heading-4">掘金推文</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS事件循环&quot;&gt;&lt;a href=&quot;#JS事件循环&quot; class=&quot;headerlink&quot; title=&quot;JS事件循环&quot;&gt;&lt;/a&gt;JS事件循环&lt;/h1&gt;&lt;h2 id=&quot;为什么js是单线程？&quot;&gt;&lt;a href=&quot;#为什么js是单线程？&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS new操作符</title>
    <link href="http://example.com/2020/08/28/js-new/"/>
    <id>http://example.com/2020/08/28/js-new/</id>
    <published>2020-08-27T19:31:25.000Z</published>
    <updated>2020-12-14T03:53:29.580Z</updated>
    
    <content type="html"><![CDATA[<p><strong>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</strong></p><ul><li>new操作符做了什么？</li><li>模拟实现JS的new操作符</li></ul><h2 id="new操作符做了什么？"><a href="#new操作符做了什么？" class="headerlink" title="new操作符做了什么？"></a>new操作符做了什么？</h2><p><strong>new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象</strong></p><ol><li>创建一个空的对象</li><li>将空对象的原型prototype指向构造函数的原型</li><li>将空对象作为构造函数的上下文（改变this指向）</li><li>确保返回的是对象</li></ol><h3 id="构造函数返回值的判断-对第4步的解析"><a href="#构造函数返回值的判断-对第4步的解析" class="headerlink" title="构造函数返回值的判断(对第4步的解析)"></a>构造函数返回值的判断(对第4步的解析)</h3><blockquote><p>一般情况下构造函数没有返回值，但是作为函数，是可以有返回值的。<br>那么在构造函数有返回值的情况下，new操作符做了什么？</p></blockquote><p>先看两个例子：<br>注意一下两个返回值的差异</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return undefined/NaN/&#x27;string&#x27;/null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;快乐每一天&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// &#123; name:&#x27;快乐每一天&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>:<span class="number">12</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;快乐每一天&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// &#123; age:12 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>在new的时候，会对构造函数的返回值做一些判断：</p><blockquote><ol><li>如果返回值是基础数据类型，则忽略返回值；</li><li>如果返回值是引用数据类型，则使用return 的返回，也就是new操作符无效；</li></ol></blockquote><h2 id="模拟实现JS的new操作符"><a href="#模拟实现JS的new操作符" class="headerlink" title="模拟实现JS的new操作符"></a>模拟实现JS的new操作符</h2><h3 id="proto和prototype区别"><a href="#proto和prototype区别" class="headerlink" title="proto和prototype区别"></a>proto和prototype区别</h3><blockquote><p><strong>方法</strong>（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性proto，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。<br><strong>方法</strong>这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</p></blockquote><p><img src="proto.jpg" alt="proto"></p><h3 id="分析图片"><a href="#分析图片" class="headerlink" title="分析图片"></a>分析图片</h3><blockquote><p><strong>1. 构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。<br>2. 原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。<br>3. 实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</strong></p></blockquote><p>另外：构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。<br><strong>原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。</strong><br>实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，<strong>指向构造函数的原型对象</strong>，这样子就可以像上面1所说的访问原型对象的所有方法啦。<br>另外：<strong>构造函数</strong>Foo()除了是方法，也是对象啊，它也有proto属性，指向谁呢？<br><strong>指向它的构造函数的原型对象</strong>。函数的构造函数不就是Function嘛，因此这里的proto指向了Function.prototype。<br>其实除了Foo()，Function(), Object()也是一样的道理。<br><strong>原型对象</strong>也是对象啊，它的proto属性，又指向谁呢？<br>同理，<strong>指向它的构造函数的原型对象</strong>。这里是Object.prototype.最后，Object.prototype的proto属性指向null。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p><strong>对象有属性proto,指向该对象的构造函数的原型对象。<br>方法除了有属性proto,还有属性prototype，prototype指向该方法的原型对象。</strong></p></blockquote><h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 先创建一个空的新对象<br>2. 因为 obj 对象需要访问到构造函数原型链上的属性，所以空对象的proto需要指向后遭函数的prototype<br>3. 将obj绑定到构造函数中，并传入其余参数（改变this指向）<br>4. 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值</strong><br>接下来我们来使用下该函数，看看是否和 new 操作符一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = create(Test, <span class="string">&#x27;yck&#x27;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// &#x27;yck&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age) <span class="comment">// 26</span></span><br><span class="line">a.sayName() <span class="comment">// &#x27;yck&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new操作符做了什么？&lt;/li&gt;
&lt;li&gt;模拟实现JS的new操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;new操作符做了什么？&quot;&gt;</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="new" scheme="http://example.com/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>JS事件的三个阶段</title>
    <link href="http://example.com/2020/08/25/js-event/"/>
    <id>http://example.com/2020/08/25/js-event/</id>
    <published>2020-08-24T19:18:19.000Z</published>
    <updated>2020-12-14T03:53:21.899Z</updated>
    
    <content type="html"><![CDATA[<p><strong>事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段。<br>事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这个路径回溯到文档跟节点。</strong><br><img src="event.png" alt="事件"></p><ul><li>捕获阶段</li><li>目标阶段</li><li>冒泡阶段</li><li>事件代理</li></ul><h2 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h2><p><strong>当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。</strong></p><p><img src="event3.png" alt="事件捕获"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#ancestors</span>&#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: red;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#father</span>&#123;</span></span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background: blue;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#son</span>&#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: green;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ancestors&quot;</span>&gt;</span>祖先</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span>父亲</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span>儿子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ancestors&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;祖先&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;父亲&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;son&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;儿子&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="event.jpg" alt="事件捕获"><br><img src="event1.jpg" alt="事件捕获"><br><strong>当我点击儿子的时候，就会从最外层开始触发，因为没有对document/html/body进行监听，所以从祖先开始触发，直到目标节点</strong></p><h2 id="目标阶段"><a href="#目标阶段" class="headerlink" title="目标阶段"></a>目标阶段</h2><p><strong>当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发，然后会逆向回流，直到传播至最外层的文档节点。</strong></p><h2 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h2><p><strong>事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点（文档）。所有现代浏览器都支持事件冒泡，并且会将事件一直冒泡到window对象</strong><br><img src="event2.png" alt="事件冒泡"></p><p>示例（html代码同上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ancestors&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;祖先&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;父亲&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;son&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;儿子&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="event2.jpg" alt="事件冒泡"><br><strong>当点击儿子的时候，事件在儿子元素上触发后，开始逐级向上冒泡。</strong></p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><blockquote><p>事件代理就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。<br>举个例子：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。<br>这里其实还有2层意思的：<br>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p></blockquote><h3 id="为什么要用事件代理"><a href="#为什么要用事件代理" class="headerlink" title="为什么要用事件代理"></a>为什么要用事件代理</h3><p><strong>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件代理，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</strong></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>比如现在我们需要对一个100行10列表格里的每一个td进行事件监听，当点击某个表格的时候则变为可编辑状态。如果把事件处理器加到这1000个单元格会产生一个很大的性能问题，并且有可能导致内存泄露甚至是浏览器的崩溃。相反地，使用事件代理，你只需要把一个事件处理器添加到table元素上就可以了，这个函数可以把点击事件给截下来，并且判断出是哪个单元格被点击了。<br><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>6<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>7<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>8<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>9<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;table&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">table.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.eventPhase) <span class="comment">// 判断当前的事件阶段（1：捕获，2：目标，3：冒泡）</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.nodeName.toLowerCase() === <span class="string">&#x27;td&#x27;</span>)&#123; <span class="comment">// 只有点击的是td才会触发</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.target)</span><br><span class="line">  <span class="built_in">console</span>.log(event.currentTarget) <span class="comment">// 监听器触发事件的元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="event3.jpg" alt="事件代理"><br><img src="event4.jpg" alt="事件代理"><br>当我点击5的时候，td就会通过事件冒泡到绑定的触发器table元素，然后获取到你点击的元素。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>通过刚才的对比介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点： 1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。 2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。 3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段。&lt;br&gt;事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动</title>
    <link href="http://example.com/2020/08/22/css-clear-float/"/>
    <id>http://example.com/2020/08/22/css-clear-float/</id>
    <published>2020-08-21T19:09:35.000Z</published>
    <updated>2020-12-14T03:52:37.348Z</updated>
    
    <content type="html"><![CDATA[<p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫<strong>浮动溢出</strong>，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br><strong>清除浮动的本质：主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题。</strong></p><ul><li>示例</li><li>方法</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    background-color: darksalmon;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line">    background-color: aquamarine;</span><br><span class="line">    float: right;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="float.jpg" alt="float"><br><strong>容器没有包含浮动元素</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="使用带clear属性的块级元素-不推荐"><a href="#使用带clear属性的块级元素-不推荐" class="headerlink" title="使用带clear属性的块级元素(不推荐)"></a>使用带clear属性的块级元素(不推荐)</h3><blockquote><p><strong>在浮动元素后面添加一个带clear属性的块级元素<br>优点：简单，代码少，浏览器支持好<br>缺点：如果页面浮动布局多，则需要很多空标签</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.clear</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 添加 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="clear.jpg" alt="清除浮动"></p><h3 id="使用CSS的overflow属性-不推荐"><a href="#使用CSS的overflow属性-不推荐" class="headerlink" title="使用CSS的overflow属性(不推荐)"></a>使用CSS的overflow属性(不推荐)</h3><blockquote><p><strong>给浮动元素的容器添加overflow属性<br>优点：不存在结构和语义化问题，代码量极少 　　<br>缺点：多个嵌套后，firefox某些情况会造成内容全选；</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line"><span class="css">    <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>; <span class="comment">/*添加,或者overflow:auto;*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用CSS的-after伪元素-推荐使用"><a href="#使用CSS的-after伪元素-推荐使用" class="headerlink" title="使用CSS的:after伪元素(推荐使用)"></a>使用CSS的:after伪元素(推荐使用)</h3><blockquote><p><strong>给浮动元素的容器添加一个class，然后给这个class添加一个:after伪元素实现元素末尾添加一个隐藏的块级元素清理浮动。<br>优点：兼容性好<br>缺点：ie6-7不支持伪元素：after</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123; <span class="comment">/*添加*/</span></span></span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: block;</span><br><span class="line">      height: 0;</span><br><span class="line">      clear: both;</span><br><span class="line">      visibility: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用before和after双伪元素清除浮动-推荐使用"><a href="#使用before和after双伪元素清除浮动-推荐使用" class="headerlink" title="使用before和after双伪元素清除浮动(推荐使用)"></a>使用before和after双伪元素清除浮动(推荐使用)</h3><p>**给浮动元素的容器添加一个class，然后给这个class添加一个:after伪元素实现元素末尾添加一个隐藏的块级元素清理浮动。<br>**</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after.clearfix</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: table;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line">      clear: both;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="容器浮动-不推荐"><a href="#容器浮动-不推荐" class="headerlink" title="容器浮动(不推荐)"></a>容器浮动(不推荐)</h3><p>**让浮动元素的容器也浮动起来<br>优点：代码少<br>缺点：会导致整个页面大部分都处于浮动状态，容易出现问题 **</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="container.jpg" alt="清除浮动"><br><strong>因为没给容器设置宽度</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫&lt;strong&gt;浮动溢出&lt;/st</summary>
      
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
    <category term="float" scheme="http://example.com/tags/float/"/>
    
  </entry>
  
  <entry>
    <title>压缩算法</title>
    <link href="http://example.com/2020/08/21/js-compress/"/>
    <id>http://example.com/2020/08/21/js-compress/</id>
    <published>2020-08-20T19:05:28.000Z</published>
    <updated>2020-12-14T03:53:17.671Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目描述</li><li>思路</li><li>代码</li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为m|S，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入第一行包含一个字符串s，代表压缩后的字符串。<br>S的长度&lt;=1000;<br>S仅包含大写字母、[、]、|;<br>解压后的字符串长度不超过100000;<br>压缩递归层数不超过10层;</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p><strong>输出一个字符串，代表解压后的字符串。</strong></p></blockquote><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p><strong>HG[3|B[2|CA]]F</strong></p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p><strong>HGBCACABCACABCACAF<br>HG[3|B[2|CA]]F−&gt;HG[3|BCACA]F−&gt;HGBCACABCACABCACAF</strong></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过<strong>递归</strong>的方法实现，每次寻找最内层的[n|xx]通过截取n和xx字符串，将[n|xx]解压并替换，再将当前的字符串递归，直至字符串没有[n|xx]，输出字符串。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\[\d+\|[A-Z]*\]/</span> <span class="comment">// 匹配最内层的[n|xxx]的正则表达式</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/\|/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str1 = reg.exec(str)</span><br><span class="line">  <span class="keyword">if</span> (!str1)&#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> substr = str1[<span class="number">0</span>] <span class="comment">// 最内层的[n|xxx]</span></span><br><span class="line">  <span class="keyword">const</span> index = str1.index <span class="comment">// 最内层的[n|xxx]索引</span></span><br><span class="line">  <span class="keyword">const</span> mindex = reg2.exec(substr).index <span class="comment">// 代表&#x27;|&#x27;符号的index</span></span><br><span class="line">  <span class="keyword">const</span> num = <span class="built_in">Number</span>(substr.slice(<span class="number">1</span>,mindex)) <span class="comment">//n</span></span><br><span class="line">  <span class="keyword">const</span> sonstr = substr.slice(mindex+<span class="number">1</span>,-<span class="number">1</span>) <span class="comment">// xxx</span></span><br><span class="line">  <span class="keyword">const</span> str2 = str.replace(reg,sonstr.repeat(num))</span><br><span class="line">  compress(str2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;题目描述&lt;/li&gt;
&lt;li&gt;思路&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;小Q想要给他的朋友发送一个</summary>
      
    
    
    
    <category term="递归" scheme="http://example.com/categories/%E9%80%92%E5%BD%92/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>数组扁平化</title>
    <link href="http://example.com/2020/08/12/array-flat/"/>
    <id>http://example.com/2020/08/12/array-flat/</id>
    <published>2020-08-11T18:58:28.000Z</published>
    <updated>2020-12-14T03:52:22.508Z</updated>
    
    <content type="html"><![CDATA[<p>数组扁平化是指将一个多维数组变为一维数组<br>[1, [2, 3, [4, 5]]] ——&gt; [1, 2, 3, 4, 5]</p><ul><li>递归法</li><li>reduce 实现</li><li>split法</li><li>正则匹配</li><li>ES6</li></ul><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p><strong>通过判断当前是否是数组，然后通过递归实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unction flatten (arr) &#123;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line">arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">res = res.concat(flatten(item))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line">arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">res = res.concat(flatten(item))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="split法"><a href="#split法" class="headerlink" title="split法"></a>split法</h2><p>如果一个需要实现扁平化的数组里都是<strong>数字</strong>类型的话可以用下面这种方法&gt;数字类型的话可以用下面这种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    arr.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function">(<span class="params">item</span>) =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Number</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p><strong>通过正则匹配将‘[’或者‘]’符号替换成空字符串</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="string">`[<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(array).replace(<span class="regexp">/\[|]/g</span>,<span class="string">&#x27;&#x27;</span>)&#125;</span>]`</span>)</span><br><span class="line">handle(array)</span><br></pre></td></tr></table></figure><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="flat（）"><a href="#flat（）" class="headerlink" title="flat（）"></a>flat（）</h3><p><strong>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>注意flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p><h3 id="或者使用Infinity关键字"><a href="#或者使用Infinity关键字" class="headerlink" title="或者使用Infinity关键字"></a>或者使用<strong>Infinity</strong>关键字</h3><blockquote><p>Infinity(无穷大)在 JS 中是一个特殊的数字，它的特性是：它比任何有限的数字都大<br>JS中的Infinity表示无穷数的概念。 任何有限数均小于Infinity，而任何有限数均大于-Infinity。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.flat(<span class="literal">Infinity</span>)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>实现方法有很多，原理基本一样，只要你对js熟悉，可以有很多实现方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组扁平化是指将一个多维数组变为一维数组&lt;br&gt;[1, [2, 3, [4, 5]]] ——&amp;gt; [1, 2, 3, 4, 5]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归法&lt;/li&gt;
&lt;li&gt;reduce 实现&lt;/li&gt;
&lt;li&gt;split法&lt;/li&gt;
&lt;li&gt;正则匹配&lt;/li&gt;</summary>
      
    
    
    
    <category term="array" scheme="http://example.com/categories/array/"/>
    
    
    <category term="array" scheme="http://example.com/tags/array/"/>
    
    <category term="flat" scheme="http://example.com/tags/flat/"/>
    
  </entry>
  
  <entry>
    <title>js实现最优打字策略</title>
    <link href="http://example.com/2020/08/05/js-optimal-write/"/>
    <id>http://example.com/2020/08/05/js-optimal-write/</id>
    <published>2020-08-04T18:52:23.000Z</published>
    <updated>2020-12-14T03:53:33.900Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道京东校招的笔试题目，有两种实现方式，最好的实现方式是通过贪心算法，本篇还未通过贪心算法实现，后续会继续实现。</p><ul><li>题目描述</li><li>思路</li><li>代码</li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在英文的输入中，我们经常会遇到大小写切换的问题，频繁切换大小写会增加我们的按键次数，也会降低我们的打字效率。 众所周知，切换大小写有两种方式：</p><ul><li>一种是按下”caps locks”，也就是大写锁定键，这样一来，之后的输入模式都会被切换。</li><li>另一种是同时按下shift和需要打印的字母，可以临时切换大小写（算作按下两个键）。<br>已知初始状态下，打字模式是小写，现在给出需要打印的字符串（区分大小写），请你计算出最少需按键多少次才能打印出来。</li></ul><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p><strong>输入第一行仅包含一个正整数n，表示字符串的长度（1&lt;=n&lt;=1000000)<br>输入第二行包含一个长度为n的字符串，仅包含大小写字母</strong></p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p><strong>输出仅包含一个正整数，即最少的按键次数。</strong></p></blockquote><h3 id="样例输入："><a href="#样例输入：" class="headerlink" title="样例输入："></a>样例输入：</h3><blockquote><p><strong>6<br>AaAAAA</strong></p></blockquote><h3 id="样例输出："><a href="#样例输出：" class="headerlink" title="样例输出："></a>样例输出：</h3><blockquote><p><strong>8</strong></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这是一道值得思考的题</strong></p><ul><li>如果当前是小写模式，并且当前字母是小写，那么直接加一，这样最省事。</li><li>如果当前是小写模式，而当前字母是大写，这样就有两种选择了。</li></ul><ol><li>按下caps lock键，切换到大写模式</li><li>同时按下shift键和当前字母。</li></ol><ul><li><p>那么哪种模式好呢？</p><blockquote><p>这就需要看一看它的下一个字符，如果仍然为大写，那么当然按下caps lock更好，并切换成当前为大写模式；<br>如果为小写，那么按下shift最好。</p></blockquote></li><li><p>大写反之</p></li></ul><p><strong>注意点</strong></p><ul><li>大写和小写总共两种状态，我们可以用0表示小写，1表示大写。</li><li>对最后一个字符进行处理，if i == len(s)-1: …，这样只要没到最后一个字符，就可以在后面通过判断i 和 i+1来处理。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="简单逻辑做法"><a href="#简单逻辑做法" class="headerlink" title="简单逻辑做法"></a>简单逻辑做法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUpper</span> (<span class="params">code</span>) </span>&#123; <span class="comment">// 判断字母是否为大写</span></span><br><span class="line">  <span class="keyword">return</span> code === code.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMin</span>(<span class="params">len,arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span> <span class="comment">// 按下次数</span></span><br><span class="line">  <span class="keyword">var</span> status = <span class="number">0</span> <span class="comment">// 0代表当前状态为小写 1代表大写</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isUpper(<span class="built_in">String</span>(arr[i])))&#123; <span class="comment">// 如果是大写</span></span><br><span class="line">      <span class="keyword">if</span> (status === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (isUpper(<span class="built_in">String</span>(arr[i + <span class="number">1</span>])) &amp;&amp; i !== (len-<span class="number">1</span>))&#123; <span class="comment">// 判断大写的字母是否连续</span></span><br><span class="line">          status = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        num += <span class="number">2</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 如果是小写</span></span><br><span class="line">      <span class="keyword">if</span> (status === <span class="number">0</span>)&#123;</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num += <span class="number">2</span></span><br><span class="line">        status = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="string">&#x27;AAAaAAaAaaA&#x27;</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="string">&#x27;AaAAAA&#x27;</span></span><br><span class="line">checkMin(<span class="number">10</span>,arr) <span class="comment">// 15</span></span><br><span class="line">checkMin(<span class="number">7</span>,arr1) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一道京东校招的笔试题目，有两种实现方式，最好的实现方式是通过贪心算法，本篇还未通过贪心算法实现，后续会继续实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题目描述&lt;/li&gt;
&lt;li&gt;思路&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>作用域var和let和const的区别</title>
    <link href="http://example.com/2020/06/03/es6-let-const-var/"/>
    <id>http://example.com/2020/06/03/es6-let-const-var/</id>
    <published>2020-06-02T18:43:45.000Z</published>
    <updated>2020-12-14T03:52:59.908Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 之前 JavaScript没有块级作用域,只有<strong>全局作用域</strong>和<strong>函数作用域</strong>。ES6的到来，为我们提供了<strong>‘块级作用域’</strong>,可通过新增命令let和const来体现。</p><ul><li>作用域(Scope)</li><li>var和let和const的区别</li></ul><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><p><strong>作用域是可访问变量的集合。</strong></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">&quot;内层变量&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Fun();</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure><p><img src="test1.JPG" alt="scope"><br>从上面的例子中可以看出，因在全局作用域里没有声明value变量，所以在全局作用域下取值会报错。简单理解:<strong>作用域就像一个独立的区域，让变量不会外泄。</strong></p><h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --全局作用域的变量声明--</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">&quot;外层变量1&quot;</span></span><br><span class="line"><span class="keyword">var</span> outVariable = <span class="string">&#x27;外层变量2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作用域</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">&quot;内层变量1&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">&#x27;内层变量2&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;可以访问到&#x27;</span> + outVariable)</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fun();</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 不同作用域同名变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable);</span><br></pre></td></tr></table></figure><p><img src="test2.JPG" alt="scope"><br>从上面的例子可以看出函数作用域内的value变量和全局作用域的value并不会冲突。而且外层作用域不能访问到内层的变量，而内层可以访问到外层的变量，所以<br><strong>隔离变量，不同作用域下同名变量不会有冲突。<br>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。</strong></p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p><strong>ES6中新增了块级作用域，使用let声明的变量只能在块级作用域里访问，有<font color='red'>“暂时性死区”</font>的特性（也就是说声明前不可用）。</strong></p><p>块作用域由 { } 包括，主要是以下几种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件语句</span></span><br><span class="line"><span class="keyword">if</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch语句</span></span><br><span class="line"><span class="keyword">switch</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for / while循环语句</span></span><br><span class="line"><span class="keyword">for</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try...catch语句</span></span><br><span class="line"><span class="keyword">try</span> () <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单大括号</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意: 对象的大括号内不是一个块级作用域, 因为它里面不能直接声明变量;</strong></p><h2 id="var和let和const的区别"><a href="#var和let和const的区别" class="headerlink" title="var和let和const的区别"></a>var和let和const的区别</h2><ul><li><strong>var</strong>定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。且存在<strong>变量提升</strong>现象</li><li><strong>let</strong>定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不存在变量提升现象</li><li><strong>const</strong>用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> c = <span class="number">2</span></span><br><span class="line">      <span class="keyword">const</span> aa = <span class="number">6</span></span><br><span class="line">      <span class="keyword">const</span> cc <span class="comment">//报错</span></span><br><span class="line">      <span class="built_in">console</span>.log(c); <span class="comment">// 2</span></span><br><span class="line">      <span class="comment">// 可见，let能在块作用域里访问</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// 可见，通过var定义的变量可以跨块作用域访问到。</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(c); <span class="comment">// 报错：c is not defined</span></span><br><span class="line">  <span class="comment">//可见，通过let定义的变量不能跨块访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">4</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 报错</span></span><br><span class="line">  <span class="comment">// 可见，通过var定义的变量不能跨函数作用域访问到</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(d);</span><br><span class="line">  <span class="comment">//可见，通过let定义的变量不能跨函数访问</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ES6 之前 JavaScript没有块级作用域,只有&lt;strong&gt;全局作用域&lt;/strong&gt;和&lt;strong&gt;函数作用域&lt;/strong&gt;。ES6的到来，为我们提供了&lt;strong&gt;‘块级作用域’&lt;/strong&gt;,可通过新增命令let和const来体现。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="es6" scheme="http://example.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://example.com/tags/es6/"/>
    
    <category term="let" scheme="http://example.com/tags/let/"/>
    
    <category term="const" scheme="http://example.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>JS获取URL中参数值</title>
    <link href="http://example.com/2020/06/02/js-getUrl/"/>
    <id>http://example.com/2020/06/02/js-getUrl/</id>
    <published>2020-06-01T18:38:41.000Z</published>
    <updated>2020-12-14T03:53:25.859Z</updated>
    
    <content type="html"><![CDATA[<p>当你进行表单提交用到get的方式的时候，经常会需要在跳转页面中获取URL中的参数，所以本篇就介绍获取URL参数的两种方法：</p><ul><li>正则法</li><li>split拆分法</li></ul><h2 id="正则法"><a href="#正则法" class="headerlink" title="正则法"></a>正则法</h2><p><strong>通过正则表达式对URL进行匹配</strong></p><h3 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetQueryString</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;(^|&amp;)&#x27;</span> + name + <span class="string">&#x27;=([^&amp;]*)(&amp;|$)&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);<span class="comment">//匹配URL的&#x27;?&#x27;符之后的正则表达式</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分函数解析"><a href="#部分函数解析" class="headerlink" title="部分函数解析"></a>部分函数解析</h3><blockquote><p><strong>RegExp()</strong><br>RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。<br><strong>substr()</strong><br>在字符串中抽取从 start 下标开始的指定数目的字符。<br><strong>unescape()</strong><br>对通过 escape() 编码的字符串进行解码。</p></blockquote><h2 id="split拆分法"><a href="#split拆分法" class="headerlink" title="split拆分法"></a>split拆分法</h2><h3 id="函数代码-1"><a href="#函数代码-1" class="headerlink" title="函数代码"></a>函数代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetQueryValue</span>(<span class="params">queryName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> query = <span class="built_in">unescape</span>(<span class="built_in">window</span>.location.search.substr(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> vars = query.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> pair = vars[i].split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pair[<span class="number">0</span>] == queryName) &#123;</span><br><span class="line">            <span class="keyword">return</span> pair[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当你进行表单提交用到get的方式的时候，经常会需要在跳转页面中获取URL中的参数，所以本篇就介绍获取URL参数的两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则法&lt;/li&gt;
&lt;li&gt;split拆分法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正则法&quot;&gt;&lt;a href=&quot;#正则法&quot; c</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://example.com/2020/05/28/vue-life/"/>
    <id>http://example.com/2020/05/28/vue-life/</id>
    <published>2020-05-27T18:15:55.000Z</published>
    <updated>2020-12-14T03:53:46.343Z</updated>
    
    <content type="html"><![CDATA[<p>Vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。</p><ul><li>vue生命周期</li><li>代码详解</li></ul><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue-life"></p><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不 同阶段添加自己的代码的机会。<br>如下是Vue生命周期的所有钩子函数</p><p><strong>beforeCreate(创建前)<br>created(创建后)<br>beforeMount(挂载前)<br>mounted(挂载后)<br>beforeUpdate(更新前)<br>uptaded(更新后)<br>beforeDestory(销毁前)<br>destoryed(销毁后)</strong></p><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p><strong>测试代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue的生命周期详解<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;beforeCreate&#x27;</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;Created&#x27;</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;beforeMount&#x27;</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;mounted&#x27;</span>)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>控制台输出结果</strong><br><img src="test.JPG" alt="控制台输出结果"></p><p>通过控制台的输出结果可以看到vue实例创建的过程中调用的钩子函数以及顺序</p><h3 id="beforeCreate-创建前"><a href="#beforeCreate-创建前" class="headerlink" title="beforeCreate(创建前)"></a>beforeCreate(创建前)</h3><blockquote><p><strong>（beforeCreate钩子函数）在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用，此时的数据观察和事件机制都未形成，不能获得DOM节点。</strong></p></blockquote><h3 id="created-创建后"><a href="#created-创建后" class="headerlink" title="created(创建后)"></a>created(创建后)</h3><blockquote><p><strong>在这个阶段vue实例已经创建，但仍然不能获取DOM元素。<br>数据已经和data属性进行绑定（可以改变data属性的值，但不会触发其他钩子函数，可以在这里对初始数据的获取。）</strong></p></blockquote><p><font color='red'><strong>注意</strong></font><br><strong>如果要在此阶段中进行dom操作，就要将操作都放在 Vue.nextTick() 的回调函数中，因为created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick() 的回调函数中。</strong></p><p>我们在created钩子函数中加入如下语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,vm.$el.textContent)</span><br></pre></td></tr></table></figure><p><img src="created_error.JPG" alt="控制台输出结果"></p><p><strong>用Vue.nextTick将操作dom元素的语句放进其回调函数中就有效果。</strong></p><h3 id="beforeMount-载入前"><a href="#beforeMount-载入前" class="headerlink" title="beforeMount(载入前)"></a>beforeMount(载入前)</h3><blockquote><p><strong>在这个阶段首先判断vue实例中有没有el选项，有则继续编译，否则停止生命周期，直到vue实例上调用vm.$mount(el)<br>如果有el，再判断是否有template参数，有则将其当作模板编译成render函数，否则把外部HTML作为模板编译。template中的模板优先级高于outer HTML模板。</strong></p></blockquote><p><strong>调用vm.$mount(el)</strong></p><p><img src="beforeMount.png" alt="beforeMount"></p><p><strong>在控制台里调用vm.$mount(el)之后生命周期则继续</strong><br>测试优先级的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;这是外部的html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;this is createElement&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span> +<span class="string">&#x27;这是在template中的&#x27;</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>当render函数存在时，页面显示</strong><br><img src="test2.JPG" alt="beforeMount"><br><strong>当render函数注释掉，template存在时，页面显示</strong><br><img src="test3.JPG" alt="beforeMount"><br><strong>当把render函数和template注释掉时，页面显示</strong><br><img src="test4.JPG" alt="beforeMount"></p><p><strong>综合排名优先级：<font color='red'>render函数选项 &gt; template选项 &gt; outer HTML</font></strong></p><h3 id="mounted-载入后"><a href="#mounted-载入后" class="headerlink" title="mounted(载入后)"></a>mounted(载入后)</h3><blockquote><p><strong>载入后html已经渲染(ajax请求可以放在这个函数中)，把vue实例中的data里的message挂载到BOM节点中去<br>实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。</strong></p></blockquote><h3 id="beforeUpdate-更新前-和updated-更新后"><a href="#beforeUpdate-更新前-和updated-更新后" class="headerlink" title="beforeUpdate(更新前)和updated(更新后)"></a>beforeUpdate(更新前)和updated(更新后)</h3><blockquote><p><strong>当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。</strong></p></blockquote><p>更改data数据输出结果<br><img src="update.png" alt="beforeMount"></p><h3 id="beforeDestroy-销毁前"><a href="#beforeDestroy-销毁前" class="headerlink" title="beforeDestroy(销毁前)"></a>beforeDestroy(销毁前)</h3><blockquote><p><strong>实例销毁之前调用。在这一步，实例仍然完全可用。</strong></p></blockquote><h3 id="destroyed-销毁后"><a href="#destroyed-销毁后" class="headerlink" title="destroyed(销毁后)"></a>destroyed(销毁后)</h3><blockquote><p><strong>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vue生命周期&lt;/li&gt;
&lt;li&gt;代码详解&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JS快速排序算法</title>
    <link href="http://example.com/2020/05/19/sort-quick/"/>
    <id>http://example.com/2020/05/19/sort-quick/</id>
    <published>2020-05-18T17:12:36.000Z</published>
    <updated>2020-12-14T03:51:14.490Z</updated>
    
    <content type="html"><![CDATA[<ul><li>为什么选择快速排序？</li><li>实现思路</li><li>代码实现</li><li>总结</li></ul><h2 id="为什么选择快速排序？"><a href="#为什么选择快速排序？" class="headerlink" title="为什么选择快速排序？"></a>为什么选择快速排序？</h2><p>相比传统的排序算法（for循环嵌套），时间复杂度由**O(n²) =&gt; O(logn)**。当数据量大的时候就会体现出快排与传统的排序速度的差异，下面我来实现快排的一种方法。</p><h2 id="各大排序算法比较"><a href="#各大排序算法比较" class="headerlink" title="各大排序算法比较"></a>各大排序算法比较</h2><table>  <tbody><tr>    <th rowspan="2">类别</th>    <th rowspan="2">排序方法</th>    <th colspan="3">时间复杂度</th>    <th>空间复杂度</th>    <th rowspan="2">稳定性</th>  </tr>  <tr>    <td>平均情况</td>    <td>最好情况</td>    <td>最坏情况</td>    <td>辅助存储</td>  </tr>  <tr>    <td rowspan="2">插入排序</td>    <td>直接插入</td>    <td>O(n²)</td>    <td>O(n)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>稳定</td>  </tr>  <tr>    <td>Shell排序</td>    <td>O(n^1.3)</td>    <td>O(n)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>不稳定</td>  </tr>  <tr>    <td rowspan="2">选择排序</td>    <td>直接选择</td>    <td>O(n²)</td>    <td>O(n²)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>不稳定</td>  </tr>  <tr>    <td>堆排序</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(1)</td>    <td>不稳定</td>  </tr>  <tr>    <td rowspan="2">狡猾排序</td>    <td>冒泡排序</td>    <td>O(n²)</td>    <td>O(n)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>稳定</td>  </tr>  <tr>    <td>快速排序</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(n²)</td>    <td>O(n)</td>    <td>不稳定</td>  </tr>  <tr>    <td colspan="2">归并排序</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(n)</td>    <td>稳定</td>  </tr>  <tr>    <td colspan="2">基数排序</td>    <td>O(d(r+n))</td>    <td>O(d(n+rd))</td>    <td>O(d(r+n))</td>    <td>O(rd+n)</td>    <td>稳定</td>  </tr></tbody></table><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-确定基准数"><a href="#1-确定基准数" class="headerlink" title="1. 确定基准数"></a>1. 确定基准数</h3><p>基准数就是选一个数作为标准,方便其他的数和它比较的一个数。<br>我们将数组的第一个数作为基准数，将大于基准数的放在基准数的右边，小于基准数的放在放在基准数的左边。</p><h3 id="2-确定数组的边界"><a href="#2-确定数组的边界" class="headerlink" title="2. 确定数组的边界"></a>2. 确定数组的边界</h3><p>定义两个变量指向序列的最左边(left)和最右边(right),让left自加直到找到大于基准数的时候停下，同理让right自减直到找到小于基准数的时候停下，将两个所对应的值进行交换。然后继续进行上步操作直到left&gt;=right。然后将left对应的值与基准数换位置。</p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>假设一个数组 arr = [6,1,2,7,9,3,4,5,10,8],对这个数组进行排序。<br><strong>初始状态</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>7</th><th>9</th><th>3</th><th>4</th><th>5</th><th>10</th><th>8</th></tr><tr><td><b>left</b></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><b>right</b></td></tr></tbody></table><p><strong>第一次<br>left和right在如下时候停下即（arr[left] &gt; 6 &amp;&amp; arr[right] &lt; 6）</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>7</th><th>9</th><th>3</th><th>4</th><th>5</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td><b>left</b></td><td></td><td></td><td></td><td><b>right</b></td><td></td><td></td></tr></tbody></table><p><strong>left和right所对应的数值交换位置</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>5</th><th>9</th><th>3</th><th>4</th><th>7</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td><b>left</b></td><td></td><td></td><td></td><td><b>right</b></td><td></td><td></td></tr></tbody></table>    <p><strong>第二次<br>与第一次同理可得</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>5</th><th>4</th><th>3</th><th>9</th><th>7</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td></td><td><b>left</b></td><td></td><td><b>right</b></td><td></td><td></td><td></td></tr></tbody></table>    <p><strong>第三次<br>left和right相遇了</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>5</th><th>4</th><th>3</th><th>9</th><th>7</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td></td><td></td><td><b>right</b>--<b>left</b></td><td></td><td></td><td></td><td></td></tr></tbody></table>    <p><strong>与基准数交换,第一次排序就完成了</strong></p><table><tbody><tr><th>3</th><th>1</th><th>2</th><th>5</th><th>4</th><th>6</th><th>9</th><th>7</th><th>10</th><th>8</th></tr></tbody></table>## 代码实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick_sort</span>(<span class="params">arr,left, right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = left</span><br><span class="line">        <span class="keyword">var</span> j = right</span><br><span class="line">        <span class="keyword">var</span> z = arr[left]</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123; <span class="comment">// 如果数组只有一个元素</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j] &gt; z &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                j--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &lt;= z &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">var</span> n = arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = n</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[i]</span><br><span class="line">        arr[i] = z</span><br><span class="line">        </span><br><span class="line">        quick_sort(arr,left,i-<span class="number">1</span>) <span class="comment">// 将基准数的左边进行排序</span></span><br><span class="line">        quick_sort(arr,i+<span class="number">1</span>,right)<span class="comment">// 将基准数的右边进行排序</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><blockquote><p>1.用下标取基数，只有一个赋值操作，更快；<br>2.原地交换，不需要新建多余的数组容器存储被划分的数据，节省存储；</p></blockquote><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><blockquote><p>1.实际测试的时候，以第一个数为基准数的快排存在速度慢，数组超过10000条数据还会出现Maximum call stack size exceeded的情况</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;为什么选择快速排序？&lt;/li&gt;
&lt;li&gt;实现思路&lt;/li&gt;
&lt;li&gt;代码实现&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么选择快速排序？&quot;&gt;&lt;a href=&quot;#为什么选择快速排序？&quot; class=&quot;headerlink&quot; title=&quot;为</summary>
      
    
    
    
    <category term="排序算法" scheme="http://example.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="快排" scheme="http://example.com/tags/%E5%BF%AB%E6%8E%92/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js数组去重-ES6</title>
    <link href="http://example.com/2020/05/18/array-unique/"/>
    <id>http://example.com/2020/05/18/array-unique/</id>
    <published>2020-05-17T17:01:54.000Z</published>
    <updated>2020-12-14T03:52:27.009Z</updated>
    
    <content type="html"><![CDATA[<p>数组去重是面试经常会遇到的问题，解决的方案有很多，本篇着重通过es6提供的新的数据结构来解决。</p><ul><li>Map对象解决去重</li><li>Set对象解决去重</li></ul><h2 id="Map对象解决去重"><a href="#Map对象解决去重" class="headerlink" title="Map对象解决去重"></a>Map对象解决去重</h2><p>Map 对象保存<strong>键值对</strong>。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><h3 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a><strong>Map对象</strong></h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">clear</td><td align="center">删除所有的键/值对，没有返回值</td></tr><tr><td align="center">delete</td><td align="center">删除某个键，返回true。如果删除失败，返回false。</td></tr><tr><td align="center">forEach</td><td align="center">对每个元素执行指定操作。</td></tr><tr><td align="center">get</td><td align="center">返回Map对象key相对应的value值。</td></tr><tr><td align="center">has</td><td align="center">返回一个布尔值，表示某个键是否在当前Map对象之中。</td></tr><tr><td align="center">set</td><td align="center">给Map对象设置key/value键/值对。</td></tr></tbody></table><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> !res.has(a) &amp;&amp; res.set(a, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Array.filter()</strong></p><blockquote><p>创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p></blockquote><h2 id="Set对象解决去重"><a href="#Set对象解决去重" class="headerlink" title="Set对象解决去重"></a>Set对象解决去重</h2><p><strong>Set对象</strong>是值的集合,元素只会出现一次,即Set中的元素是<strong>唯一</strong>的.<br>通过Set()创建的是一个对象，可以使用<strong>点语法（…）</strong>或者是<strong>Array.from</strong>将其转化为数组，然后既可以使用数组处理函数了。</p><p><strong>Set对象</strong></p><blockquote><p><strong>语法</strong>：<br>new Set([iterable])<br><strong>参数</strong>：<br>iterable，如果传递一个可迭代对象(包括 Array，Map，Set，String，TypedArray，arguments 对象等等)，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。</p></blockquote><h3 id="数组去重-1"><a href="#数组去重-1" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Array.from()</strong></p><blockquote><p>用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组去重是面试经常会遇到的问题，解决的方案有很多，本篇着重通过es6提供的新的数据结构来解决。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map对象解决去重&lt;/li&gt;
&lt;li&gt;Set对象解决去重&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Map对象解决去重&quot;&gt;&lt;a href=&quot;#Map对象解决</summary>
      
    
    
    
    <category term="array" scheme="http://example.com/categories/array/"/>
    
    
    <category term="array" scheme="http://example.com/tags/array/"/>
    
    <category term="es6" scheme="http://example.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>http和https</title>
    <link href="http://example.com/2020/04/04/http-https/"/>
    <id>http://example.com/2020/04/04/http-https/</id>
    <published>2020-04-04T14:36:03.000Z</published>
    <updated>2020-12-13T14:56:22.615Z</updated>
    
    <content type="html"><![CDATA[<ul><li>http和https的概念</li><li>http常见的状态码</li><li>http和https的区别</li><li>https相对于http的改进</li><li>https的工作原理</li></ul><h2 id="http和https的概念"><a href="#http和https的概念" class="headerlink" title="http和https的概念"></a>http和https的概念</h2><p><strong>HTTP协议</strong>是一种使用明文数据传输的网络协议。<br><strong>HTTPS协议</strong>可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。</p><hr><h2 id="http常见的状态码"><a href="#http常见的状态码" class="headerlink" title="http常见的状态码"></a>http常见的状态码</h2><table><thead><tr><th align="center">状态码</th><th align="center">响应类别</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">信息性状态码(Informational)</td><td align="center">服务器正在处理请求</td></tr><tr><td align="center">2XX</td><td align="center">成功状态码(Success)</td><td align="center">请求已正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">重定向状态码(Redirection)</td><td align="center">需要进行额外操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">客户端错误状态码(Client Error)</td><td align="center">客户端原因导致服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">服务器错误状态码（Server Error)</td><td align="center">服务器原因导致处理请求出错</td></tr></tbody></table><h3 id="1xx（信息）"><a href="#1xx（信息）" class="headerlink" title="1xx（信息）"></a>1xx（信息）</h3><blockquote><p><strong>100 Continue</strong><br>继续。客户端应继续其请求<br><strong>101 Switching Protocols</strong><br>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</p></blockquote><h3 id="2xx（成功）"><a href="#2xx（成功）" class="headerlink" title="2xx（成功）"></a>2xx（成功）</h3><blockquote><p><strong>200 OK</strong><br>表示请求被服务器正常处理<br><strong>201 Creanted</strong><br>已创建。成功请求并创建了新的资源<br><strong>202 Accepted</strong><br>已接受。已经接受请求，但未处理完成<br><strong>203 Non-Authoritative Information</strong><br>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本<br><strong>204 No Content</strong><br>表示请求已成功处理，但是没有内容返回（就应该没有内容返回的状况）<br><strong>205 Reset Content</strong><br>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域<br><strong>206 Partial Content</strong><br>表示服务器已经完成了部分GET请求（客户端进行了范围请求）</p></blockquote><h3 id="3xx（重定向）"><a href="#3xx（重定向）" class="headerlink" title="3xx（重定向）"></a>3xx（重定向）</h3><blockquote><p><strong>301 Moved Permanently</strong><br>永久重定向，表示请求的资源已经永久的搬到了其他位置<br><strong>302 Found</strong><br>临时重定向，表示请求的资源临时搬到了其他位置<br><strong>303 See Other</strong><br>表示请求资源存在另一个URI，应使用GET定向获取请求资源<br><strong>304 Not Modified</strong><br>表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足<br><strong>307 Temporary Redirect</strong><br>临时重定向，和302有着相同含义</p></blockquote><h3 id="4xx（客户端错误）"><a href="#4xx（客户端错误）" class="headerlink" title="4xx（客户端错误）"></a>4xx（客户端错误）</h3><blockquote><p><strong>400 Bad Request</strong><br>表示请求报文存在语法错误或参数错误，服务器不理解<br><strong>401 Unauthorized</strong><br>表示发送的请求需要有HTTP认证信息或者是认证失败了<br><strong>403 Forbidden</strong><br>表示对请求资源的访问被服务器拒绝了<br><strong>404 Not Found</strong><br>表示服务器找不到你请求的资源</p></blockquote><h3 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h3><blockquote><p><strong>500 Internal Server Error</strong><br>表示服务器执行请求的时候出错了<br><strong>503 Service Unavailable</strong><br>表示服务器超负载或正停机维护，无法处理请求</p></blockquote><hr><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><table><thead><tr><th align="center">协议</th><th align="center">数据加密传输(本质区别)</th><th align="center">传输协议</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">HTTP</td><td align="center">无</td><td align="center">超文本传输协议</td><td align="center">80</td></tr><tr><td align="center">HTTPS</td><td align="center">有</td><td align="center">ssl加密传输协议</td><td align="center">443</td></tr></tbody></table><h2 id="https相对于http的改进"><a href="#https相对于http的改进" class="headerlink" title="https相对于http的改进"></a>https相对于http的改进</h2><p><strong>1.双向的身份认证</strong></p><blockquote><p>客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。</p></blockquote><p><strong>2.数据传输的机密性</strong></p><blockquote><p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。</p></blockquote><p><strong>3.防止重放攻击</strong></p><blockquote><p>SSL使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。</p></blockquote><h2 id="https的工作原理"><a href="#https的工作原理" class="headerlink" title="https的工作原理"></a>https的工作原理</h2><ol><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li><li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;http和https的概念&lt;/li&gt;
&lt;li&gt;http常见的状态码&lt;/li&gt;
&lt;li&gt;http和https的区别&lt;/li&gt;
&lt;li&gt;https相对于http的改进&lt;/li&gt;
&lt;li&gt;https的工作原理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;http和https</summary>
      
    
    
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>vue插件-BetterScroll使用</title>
    <link href="http://example.com/2020/04/04/vue-scroll/"/>
    <id>http://example.com/2020/04/04/vue-scroll/</id>
    <published>2020-04-04T14:19:27.000Z</published>
    <updated>2020-12-14T03:53:53.119Z</updated>
    
    <content type="html"><![CDATA[<p>BetterScroll 是一款重点解决移动端（已支持PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。<br>BetterScroll 提供了很多灵活的 API，当我们基于 better-scroll 去实现一些 feature 的时候，会用到这些 API，了解他们会有助于开发更加复杂的需求。</p><ul><li>使用</li><li>参数</li><li>方法</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>插件的安装请看<a href="https://github.com/ustbhuangyi/better-scroll">BetterScroll</a></p><p><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JS</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.wrapperScroll = <span class="keyword">new</span> BScroll(<span class="built_in">this</span>.$refs.wrapper, &#123;</span><br><span class="line">click: <span class="literal">true</span> <span class="comment">//还可以添加其他参数(具体看下方)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>startX: 0 开始的X轴位置</li><li>startY: 0 开始的Y轴位置</li><li>scrollY: true 滚动方向为 Y 轴</li><li>scrollX: true 滚动方向为 X 轴</li><li>click: true 是否派发click事件，通常判断浏览器派发的click还是betterscroll派发的click</li><li>momentum: true 当快速滑动时是否开启滑动惯性</li><li>bounce: true 是否启用回弹动画效果</li><li>selectedIndex: 0 wheel 为 true 时有效，表示被选中的 wheel 索引</li><li>rotate: 25 wheel 为 true 时有效，表示被选中的 wheel 每一层的旋转角度</li><li>wheel: false 该属性是给 picker 组件使用的，普通的列表滚动不需要配置</li><li>snap: false 该属性是给 slider 组件使用的，普通的列表滚动不需要配置</li><li>snapLoop: false 是否可以无缝循环轮播</li><li>snapThreshold: 0.1 用手指滑动时页面可切换的阈值，大于这个阈值可以滑动的下一页</li><li>snapSpeed: 400, 轮播图切换的动画时间</li><li>swipeTime: 2500 swipe 持续时间</li><li>bounceTime: 700 弹力动画持续的毫秒数</li><li>adjustTime: 400 wheel 为 true 有用，调整停留位置的时间</li><li>swipeBounceTime: 1200 swipe 回弹 时间</li><li>deceleration: 0.001 滚动动量减速越大越快，建议不大于0.01</li><li>momentumLimitTime: 300 符合惯性拖动的最大时间</li><li>momentumLimitDistance: 15 符合惯性拖动的最小拖动距离</li><li>resizePolling: 60 重新调整窗口大小时，重新计算better-scroll的时间间隔</li><li>preventDefault: true 是否阻止默认事件</li><li>useTransition: true 是否使用CSS3的Transition属性</li><li>useTransform: true 是否使用CSS3的Transform属性</li><li>probeType: 1 滚动的时候会派发scroll事件，会截流。2 滚动的时候实时派发scroll事件，不会截流。 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h3><blockquote><p><strong>参数</strong>：无<br><strong>返回值</strong>：无<br><strong>作用</strong>：重新计算 better-scroll，当 DOM结构发生变化的时候务必要调用确保滚动的效果正常。</p></blockquote><h3 id="scrollTo-x-y-time-easing"><a href="#scrollTo-x-y-time-easing" class="headerlink" title="scrollTo(x, y, time, easing)"></a>scrollTo(x, y, time, easing)</h3><blockquote><p><strong>参数</strong>：<br>{Number} x 横轴坐标（单位 px）<br>{Number} y 纵轴坐标（单位 px）<br>{Number} time 滚动动画执行的时长（单位 ms）<br>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法<br><strong>返回值</strong>：无<br><strong>作用</strong>：滚动到指定的位置，见 Demo 。</p></blockquote><h3 id="scrollBy-x-y-time-easing"><a href="#scrollBy-x-y-time-easing" class="headerlink" title="scrollBy(x, y, time, easing)"></a>scrollBy(x, y, time, easing)</h3><blockquote><p><strong>参数</strong>：<br>{Number} x 横轴距离（单位 px）<br>{Number} y 纵轴距离（单位 px）<br>{Number} time 滚动动画执行的时长（单位 ms）<br>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法<br><strong>返回值</strong>：无<br><strong>作用</strong>：相对于当前位置偏移滚动 x,y 的距离。</p></blockquote><h3 id="scrollToElement-el-time-offsetX-offsetY-easing"><a href="#scrollToElement-el-time-offsetX-offsetY-easing" class="headerlink" title="scrollToElement(el, time, offsetX, offsetY, easing)"></a>scrollToElement(el, time, offsetX, offsetY, easing)</h3><blockquote><p><strong>参数</strong>：<br>{DOM | String} el 滚动到的目标元素, 如果是字符串，则内部会尝试调用 querySelector 转换成 DOM 对象。<br>{Number} time 滚动动画执行的时长（单位 ms）<br>{Number | Boolean} offsetX 相对于目标元素的横轴偏移量，如果设置为 true，则滚到目标元素的中心位置<br>{Number | Boolean} offsetY 相对于目标元素的纵轴偏移量，如果设置为 true，则滚到目标元素的中心位置<br>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法<br><strong>返回值</strong>：无<br><strong>作用</strong>：滚动到指定的目标元素。</p></blockquote><h3 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h3><blockquote><p><strong>参数</strong>：无<br><strong>返回值</strong>：无<br><strong>作用</strong>：立即停止当前运行的滚动动画。</p></blockquote><h3 id="enable"><a href="#enable" class="headerlink" title="enable()"></a>enable()</h3><blockquote><p><strong>参数</strong>：无<br><strong>返回值</strong>：无<br><strong>作用</strong>：启用 better-scroll, 默认 开启。</p></blockquote><h3 id="disable"><a href="#disable" class="headerlink" title="disable()"></a>disable()</h3><blockquote><p><strong>参数</strong>：无<br><strong>返回值</strong>：无<br>*<em>作用</em>：禁用 better-scroll，DOM 事件（如 touchstart、touchmove、touchend）的回调函数不再响应。</p></blockquote><h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy()"></a>destroy()</h3><blockquote><p><strong>参数</strong>：无<br><strong>返回值</strong>：无<br><strong>作用</strong>：销毁 better-scroll，解绑事件。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;BetterScroll 是一款重点解决移动端（已支持PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。&lt;br&gt;BetterSc</summary>
      
    
    
    
    <category term="vue插件" scheme="http://example.com/categories/vue%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>div高度自适应页面宽度</title>
    <link href="http://example.com/2020/03/21/css-height/"/>
    <id>http://example.com/2020/03/21/css-height/</id>
    <published>2020-03-21T13:46:29.000Z</published>
    <updated>2020-12-14T03:52:46.980Z</updated>
    
    <content type="html"><![CDATA[<p>宽度的自适应是根据viewport的width来调整的,而css属性中的padding也是根据viewport的width来计算的，那么通过设置这个属性就可以跟width达成某种比例关系。</p><h2 id="css实现高度自适应"><a href="#css实现高度自适应" class="headerlink" title="css实现高度自适应"></a>css实现高度自适应</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100%;</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">padding-bottom</span>: 30%;  //<span class="selector-tag">div</span>的高度为宽度的30%</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;宽度的自适应是根据viewport的width来调整的,而css属性中的padding也是根据viewport的width来计算的，那么通过设置这个属性就可以跟width达成某种比例关系。&lt;/p&gt;
&lt;h2 id=&quot;css实现高度自适应&quot;&gt;&lt;a href=&quot;#css实现高度自</summary>
      
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>文字溢出隐藏</title>
    <link href="http://example.com/2020/03/13/css-ellipsis/"/>
    <id>http://example.com/2020/03/13/css-ellipsis/</id>
    <published>2020-03-13T14:13:20.000Z</published>
    <updated>2020-12-14T03:52:41.169Z</updated>
    
    <content type="html"><![CDATA[<p>文本溢出隐藏在前端是很常见的需求，例如文章的标题过长，需要超出几行后隐藏，显示省略号（…）。</p><ul><li>单行文字溢出隐藏</li><li>多行文字溢出隐藏</li></ul><h3 id="单行文字溢出隐藏"><a href="#单行文字溢出隐藏" class="headerlink" title="单行文字溢出隐藏"></a>单行文字溢出隐藏</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br></pre></td></tr></table></figure><h3 id="多行文字溢出隐藏"><a href="#多行文字溢出隐藏" class="headerlink" title="多行文字溢出隐藏"></a>多行文字溢出隐藏</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span><span class="selector-pseudo">:vertical</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span><span class="selector-pseudo">:3</span>; //文本超出三行后隐藏</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文本溢出隐藏在前端是很常见的需求，例如文章的标题过长，需要超出几行后隐藏，显示省略号（…）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单行文字溢出隐藏&lt;/li&gt;
&lt;li&gt;多行文字溢出隐藏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;单行文字溢出隐藏&quot;&gt;&lt;a href=&quot;#单行文字溢出隐藏&quot; c</summary>
      
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
</feed>
