<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笨鸟</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-11T12:34:15.924Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HC-ZHAN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>箭头函数</title>
    <link href="http://example.com/2022/04/11/es6-arrow/"/>
    <id>http://example.com/2022/04/11/es6-arrow/</id>
    <published>2022-04-11T12:32:28.000Z</published>
    <updated>2022-04-11T12:34:15.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="箭头函数不绑定this"><a href="#箭头函数不绑定this" class="headerlink" title="箭头函数不绑定this"></a>箭头函数不绑定this</h3><blockquote><p><strong>箭头函数不绑定<code>this</code>，会捕获其所在的上下文的<code>this</code>值，作为自己的<code>this</code>值</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br></pre></td></tr></table></figure><p>答案输出是<code>1</code></p><p>为什么呢？<br>因为箭头函数<code>this</code>指向等于定义时上层作用域中的<code>this</code>，所以是指向最外层window</p><p>再看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = obj.foo</span><br><span class="line">bar() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">obj.foo.call(obj) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>为什么他们输出结果会不一致呢？</p><p>不是说箭头函数不会被外部影响改变，<code>call</code>和<code>apply</code>方法对箭头函数无效吗？</p><p>接下来我们来一步步分析，为了方便大家理解，我将上述代码通过babel转换成es5来分析，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(_this.id);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bar = obj.foo</span><br><span class="line">bar()</span><br><span class="line">obj.foo.call(obj);</span><br></pre></td></tr></table></figure><p>可以看出</p><blockquote><p>箭头函数里面根本没有自己的<code>this</code>，而是引用的上层作用域中<code>this</code></p></blockquote><p>我们通过 <code>call</code> 来改变 <code>this</code> 指向改变是其父级的 <code>this</code> ，箭头函数里的 <code>this</code> 永远的指向其父级的作用域，而我们只是通过改变其父级的 <code>this</code> 指针，来达到箭头函数 <code>this</code> 的修改</p><h3 id="箭头函数不绑定arguments，没有prototype原型对象"><a href="#箭头函数不绑定arguments，没有prototype原型对象" class="headerlink" title="箭头函数不绑定arguments，没有prototype原型对象"></a>箭头函数不绑定<code>arguments</code>，没有<code>prototype</code>原型对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123; <span class="built_in">console</span>.log(val) &#125;</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(val)</span><br><span class="line"><span class="built_in">console</span>.dir(f1)</span><br><span class="line"><span class="built_in">console</span>.dir(f2)</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/026549b7bd1d416a8512115310467e59~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以发现箭头函数没有<code>arguments</code>和<code>prototype</code>原型对象</p><blockquote><p>箭头函数不绑定<code>arguments</code>，取而代之用<code>rest</code>参数…解决</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数是匿名函数，不能作为构造函数，不能使用new"><a href="#箭头函数是匿名函数，不能作为构造函数，不能使用new" class="headerlink" title="箭头函数是匿名函数，不能作为构造函数，不能使用new"></a>箭头函数是匿名函数，不能作为构造函数，不能使用<code>new</code></h3><p>我们先来看看new的原理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new的原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面已知的信息，箭头函数没有<code>prototype</code>，所以无法使实例的<code>__proto__</code>指向其构造函数的原型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;箭头函数不绑定this&quot;&gt;&lt;a href=&quot;#箭头函数不绑定this&quot; class=&quot;headerlink&quot; title=&quot;箭头函数不绑定this&quot;&gt;&lt;/a&gt;箭头函数不绑定this&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;箭头函数不绑定&lt;code&gt;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="es6" scheme="http://example.com/tags/es6/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存</title>
    <link href="http://example.com/2022/04/07/http-cache/"/>
    <id>http://example.com/2022/04/07/http-cache/</id>
    <published>2022-04-07T14:07:14.000Z</published>
    <updated>2022-04-13T17:05:02.156Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p><h2 id="缓存资源"><a href="#缓存资源" class="headerlink" title="缓存资源"></a>缓存资源</h2><p>缓存资源分为 <strong>memory cache（内存缓存）</strong> 和 <strong>disk cache（磁盘缓存）</strong> </p><h3 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h3><blockquote><p>不访问服务器，直接读缓存，从<strong>内存</strong>中读取缓存。此时的数据时缓存到内存中的，当kill进程后，也就是浏览器关闭以后，数据将不存在。但是这种方式只能缓存<strong>派生资源</strong>。</p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45c47a6b1af349bbbfd4c02cc02f1da5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>我们经常看到的返回200显示from memory cache，其实就是取得是内存里的缓存</p><h3 id="disk-cache"><a href="#disk-cache" class="headerlink" title="disk cache"></a>disk cache</h3><blockquote><p>不访问服务器，直接读缓存，从<strong>磁盘</strong>中读取缓存，当kill进程时，数据还是存在。这种方式也只能缓存<strong>派生资源</strong></p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3681474fb5b547349066b76e8397a1cf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>当我们关闭页面，在缓存还未过期的时候访问的一些访问过的派生资源时，就显示200 from disk cache其实就是<strong>磁盘缓存</strong></p><h3 id="三级缓存原理-访问缓存优先级"><a href="#三级缓存原理-访问缓存优先级" class="headerlink" title="三级缓存原理 (访问缓存优先级)"></a>三级缓存原理 (访问缓存优先级)</h3><ol><li> 先在内存中查找,如果有,直接加载。</li><li> 如果内存中不存在,则在硬盘中查找,如果有直接加载。</li><li> 如果硬盘中也没有,那么就进行网络请求。</li><li> 请求获取的资源缓存到硬盘和内存。</li></ol><p>后面会有例子来证明优先级是否正确</p><hr><h2 id="失效策略分类"><a href="#失效策略分类" class="headerlink" title="失效策略分类"></a>失效策略分类</h2><p>按照失效策略分类，就包括两种 <strong>强缓存</strong> 和 <strong>协商缓存</strong></p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存主要包括 <code>expires</code> 和 <code>cache-control</code>。<br>对比来加深理解</p><table><thead><tr><th>区别</th><th>expires</th><th>cache-control</th></tr></thead><tbody><tr><td>http版本</td><td>1.0</td><td>1.1</td></tr><tr><td>时间</td><td>绝对时间</td><td>相对时间</td></tr><tr><td>优先级</td><td>低于cache-control</td><td>高于expires</td></tr><tr><td>例子</td><td>expires:Mar, 06 Apr 2020 10:47:02 GMT</td><td>Cache-Control:max-age=3600</td></tr><tr><td>代表意义(例子为例)</td><td>资源的失效时间，在此字段值之前则命中缓存</td><td>资源的有效期是 3600 秒</td></tr><tr><td>缺点</td><td>由于失效时间是一个绝对时间，因当服务器与客户端时间偏差较大时，就会导致缓存混乱</td><td>无法兼容HTTP1.0</td></tr></tbody></table><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>通过实践来看看是否符合原理</p><p>用koa2的<a href="https://www.npmjs.com/package/koa-generator">脚手架</a>创建一个项目</p><blockquote><p><code>koa2 -e koa2-learn</code> （koa2-learn代表项目名称）</p></blockquote><p>创建完成之后在public文件夹里新建一个html以及在images放一个图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public/index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>前端缓存<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.web-cache</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line">        display: block;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;web-cache&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/unique.jpg&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在app.js文件中设置cache-control</p><p>注意：新添加的代码块必须得在<code>koa-static</code>引用之前才会生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新添加 --start</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置响应头Cache-Control 设置资源有效期为300秒</span></span><br><span class="line">  ctx.set(&#123;</span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=300&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/// 新添加 --end</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)(__dirname + <span class="string">&#x27;/public&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将项目跑起来看看效果</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2baa50cc1b394d82a80ba1426c1bfaa6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>可以发现设置的<code>cache-Control</code>生效了，第一次请求浏览器会把图片存进了磁盘（<code>disk cache</code>）和内存（<code>memory cache</code>）中。</p><hr><h5 id="取内存资源"><a href="#取内存资源" class="headerlink" title="取内存资源"></a>取内存资源</h5><p>紧接着我们来刷新一下，根据<strong>三级缓存原理</strong>，我们会先在内存中找资源<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bab22485866487fba4ce7a96a52ae86~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>发现图片是直接从内存中取的，符合</p><hr><h4 id="取磁盘资源"><a href="#取磁盘资源" class="headerlink" title="取磁盘资源"></a>取磁盘资源</h4><p><code>memory cache</code>在关闭进程的时候会释放掉其中的资源，现在我们关闭浏览器，重新打开看看当内存没有该图片的时，是否会取磁盘内存里的图片</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d86a48b24bc40949cd8db27a941d642~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>发现图片取了磁盘内存，符合</p><hr><h5 id="验证cache-control"><a href="#验证cache-control" class="headerlink" title="验证cache-control"></a>验证cache-control</h5><p>我们设置的缓存有效期是300s，当过了300s后我们重新刷新一下，来验证一下缓存是否失效</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/622d7fd023fa464e94c4578b715e4583~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以发现缓存失效了，跟我们第一次请求的时候一模一样</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是通过服务器来判断缓存是否可用，服务器则根据header的信息（ <code>Last-Modify/If-Modify-Since</code> 和<code> ETag/If-None-Match</code>）来判断是否命中协商缓存，如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。</p><h4 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h4><p>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 <code>Last-Modify</code>，<code>Last-modify</code> 是一个时间标识该资源的最后修改时间。</p><p>当浏览器再次请求该资源时，request 的请求头中会包含<code>If-Modify-Since</code>，该值为缓存之前返回的 <code>Last-Modify</code>。服务器收到 <code>If-Modify-Since</code> 后，根据资源的最后修改时间判断是否命中缓存。</p><p>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p><p><strong>缺点</strong>:短时间内资源发生了改变，Last-Modified 并不会发生变化。</p><h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p>与 <code>Last-Modify/If-Modify-Since</code> 不同的是，<code>Etag/If-None-Match</code> 返回的是一个校验码。<code>ETag</code> 可以保证每一个资源是唯一的，资源变化都会导致 <code>ETag</code> 变化。</p><p>web服务器收到请求后发现有头<code>If-None-Match</code>则与<code>ETahe</code>进行对比，相同则返回<code>304</code>不同则返回<code>200</code>。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li><p>Etag与Last-Modified有什么区别？</p><blockquote><p><code>Etag</code>更倾向于标识资源是否有变更，而<code>Last-Modified</code>更倾向于含有时间状态的数据</p></blockquote></li><li><p>如果Etag和Last-Modified同时存在，服务器会先检测哪一个？</p><blockquote><p>服务器会先检测<code>Etag</code>再去检测<code>Last-Modified</code>,因为Etag发生改变的话那么资源的内容一定发生了变化，而<code>Last-Modified</code>发生了变化资源内容不一定发生改变 </p></blockquote></li></ol><h4 id="Etag实践"><a href="#Etag实践" class="headerlink" title="Etag实践"></a>Etag实践</h4><p>安装下面两个依赖</p><blockquote><p><code>yarn add koa-conditional-get</code> , <code>yarn add koa-etag</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> conditional = <span class="built_in">require</span>(<span class="string">&#x27;koa-conditional-get&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> etag = <span class="built_in">require</span>(<span class="string">&#x27;koa-etag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(conditional())</span><br><span class="line">app.use(etag())</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)(__dirname + <span class="string">&#x27;/public&#x27;</span>))</span><br></pre></td></tr></table></figure><p>看一下第一次请求的时候效果</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003bc466b25e4932be0e6069f079c326~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><p>发现已经有<code>etag</code>的值了，现在我们来刷新看看</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c2963f76f7469eac114217d54f7aac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>当我们再次请求的时候Request Headers上的<code>If-None-Match</code>已经带上了<code>Etag</code>的值了</p><hr><p>接下来我们将一个新的图片跟现有图片重命名覆盖掉，刷新请求</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed3188e40b1406c8085cd60867b54fd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>发现协商缓存失效了，Request Headers上的<code>If-None-Match</code>还是上一张图片的<code>Etag</code>值，与Response Headers返回来的<code>Etag</code>不相等所以重新请求新资源返回200。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。&lt;/p&gt;
&lt;h2 id=&quot;缓存资源&quot;&gt;&lt;a href=&quot;#缓存资源&quot;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
    <category term="cache" scheme="http://example.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>彻底弄懂Promise，并带你手写</title>
    <link href="http://example.com/2022/04/06/js-promise/"/>
    <id>http://example.com/2022/04/06/js-promise/</id>
    <published>2022-04-06T07:59:58.000Z</published>
    <updated>2022-04-06T08:02:33.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p><ul><li> <strong>等待（pending）</strong> : 初始状态，既没有被兑现，也没有被拒绝。</li><li> <strong>成功（fulfilled）</strong> : 意味着操作成功完成。</li><li> <strong>失败（rejected）</strong> : 意味着操作失败。</li></ul><p>我们来看看原生promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p0 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(p0, p1, p2, p3)</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3e5d38b1ac340048620ba9363cfdf73~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>通过输出结果我们可以总结出</p><ul><li>当没有执行<code>resolve</code>或者<code>reject</code>时，PromiseState是<code>pending</code>状态</li><li>当执行<code>resolve</code>或者<code>reject</code>时，PromiseState会变成相应的成功或失败状态</li><li>状态只能由 <code>Pending --&gt; fulfilled</code> 或者 <code>Pending --&gt; rejected</code>，且一但发生改变便不可<strong>二次</strong>修改</li></ul><hr><p>根据上面的总结，我们来一一实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化值</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 绑定this</span></span><br><span class="line">    <span class="built_in">this</span>.resolve = <span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.reject = <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// 执行传进来的函数</span></span><br><span class="line">    executor(<span class="built_in">this</span>.resolve,<span class="built_in">this</span>.reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只能是Pending --&gt; Fulfilled</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.PromiseResult = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只能是Pending --&gt; Rejected</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.PromiseResult = reason</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p01 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p11 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p21 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/840b369224424138ae36373b1ddecb7c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>可以发现已经实现了简单的功能</p><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>看看原生的promise的then</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123; resolve(<span class="string">&#x27;成功&#x27;</span>) &#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123; reject(<span class="string">&#x27;失败&#x27;</span>) &#125;)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(res)&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125;) <span class="comment">// 输出：成功</span></span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(res)&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125;) <span class="comment">// 输出：失败</span></span><br><span class="line">p3.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(res)&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125;) <span class="comment">// 3s后输出：成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>then接收两个回调函数，一个是<code>成功回调</code>，一个是<code>失败回调</code></li><li>当<code>resolve</code>或<code>reject</code>遇到定时器时,等待定时器<code>结束</code>后才执行<code>then</code></li></ul><p>遇到定时器等异步操作的时候的思路</p><ul><li>当执行<code>then</code>的时候状态是<code>pending</code>就代表遇到了异步操作，需要保存<code>then</code>里的<strong>回调</strong>在数组里</li><li>当定时器结束的时候再执行存储回调数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化值</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 异步存储回调 -----新增代码</span></span><br><span class="line">    <span class="built_in">this</span>.onFulfilledCallBack = []</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallBack = []</span><br><span class="line">    <span class="comment">// 绑定this</span></span><br><span class="line">    <span class="built_in">this</span>.resolve = <span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.reject = <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// 执行传进来的函数</span></span><br><span class="line">    executor(<span class="built_in">this</span>.resolve,<span class="built_in">this</span>.reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.PromiseResult = value</span><br><span class="line">      <span class="comment">// -----新增代码</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">this</span>.onFulfilledCallBack.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallBack.shift()(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.PromiseResult = reason</span><br><span class="line">      <span class="comment">// -----新增代码</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">this</span>.onRejectedCallBack.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallBack.shift()(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;</span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.PromiseResult)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>)&#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.PromiseResult)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123; <span class="comment">// -----新增代码</span></span><br><span class="line">      <span class="built_in">this</span>.onFulfilledCallBack.push(onFulfilled)</span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallBack.push(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>用<strong>数组</strong>保存回调的原因：Promise 的 <code>then</code> 方法是可以被<strong>多次</strong>调用的，如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(value + <span class="number">1</span>)</span><br><span class="line">&#125;) </span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value + <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>3s后输出<code>成功1</code>,<code>成功2</code></li></ul><h2 id="then的链式调用"><a href="#then的链式调用" class="headerlink" title="then的链式调用"></a>then的链式调用</h2><p>怎么让promise可以一直链式的调用then呢？<br>只需要在then执行返回一个<code>Promise对象</code>就行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 保存回调的结果</span></span><br><span class="line">        <span class="keyword">const</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult)</span><br><span class="line">        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>)&#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.PromiseResult)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallBack.push(onFulfilled)</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallBack.push(onRejected)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x,resolve,reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回 </span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123; </span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>)) </span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 判断x是不是 MyPromise 实例对象</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    x.then(resolve,reject)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加深代码的理解，我们分三种情况理解</p><p><strong>1. 当then里执行的<code>不是return</code>的时候，例如</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当上述代码执行到<code>const x = onFulfilled(this.PromiseResult)</code>这一句的时候相当于立即执行回调，等效于=&gt;<code>const x = ((res) =&gt; &#123;console.log(res)&#125;)(&#39;成功&#39;)</code></p><p><strong>2. 当then里return的是<code>普通变量</code>的时候，例如</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> res + <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行上述代码简化一下，假设resolve(&#x27;成功&#x27;)</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> x = <span class="string">&#x27;成功1&#x27;</span></span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回一个promise，当再调用then的时候就把x的值传递过去实现了链式调用</p><p><strong>3. 当then里return的是<code>promise</code>对象的时候，例如</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    resolve(res + <span class="string">&#x27;-p1.then成功&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    reject(res + <span class="string">&#x27;-p1.then失败&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b22c3b3d903493fadf3bff6cb6798de~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li>当返回值是promise对象时，成功则新promise的对象（即<code>promise2</code>）返回的是成功，反之则失败</li></ul><p>之所以在<code>resolvePromise</code>方法中,遇到promise对象调用 then 方法，是因为只有then才能知道promise返回的状态是成功还是失败。</p><p><strong>4. 当then里return的是<code>promise</code>对象自己的时候，会报错。例如</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;success&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 这个时候将promise定义一个p1，然后返回的时候返回p1这个promise</span><br><span class="line">const p1 &#x3D; promise.then(value &#x3D;&gt; &#123;</span><br><span class="line">   console.log(1)</span><br><span class="line">   console.log(&#39;resolve&#39;, value)</span><br><span class="line">   return p1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e68147986b24e25971fb3c6725e7997~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>所以我们需要对这种情况进行处理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;promise&quot;&gt;&lt;a href=&quot;#promise&quot; class=&quot;headerlink&quot; title=&quot;promise&quot;&gt;&lt;/a&gt;promise&lt;/h2&gt;&lt;p&gt;一个 &lt;code&gt;Promise&lt;/code&gt; 必然处于以下几种状态之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="promise" scheme="http://example.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>什么是跨域？教你手动模拟解决跨域</title>
    <link href="http://example.com/2021/12/15/cross-orgin/"/>
    <id>http://example.com/2021/12/15/cross-orgin/</id>
    <published>2021-12-15T14:52:30.000Z</published>
    <updated>2021-12-15T15:00:02.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>造成的，是浏览器对javascript施加的安全限制。<br><br> <strong>同源策略（Sameoriginpolicy）</strong> 是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。<br><br>所谓 <strong>同源</strong> （即指在同一个域）就是两个页面具有相同的 <strong><code>协议</code>**（protocol），</strong><code>主机</code>**（host）和 **<code>端口号</code>**（port）</p><h2 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1. jsonp"></a>1. jsonp</h3><p>我们在做项目的时候是不是经常会通过<code>script</code>标签来引入资源，但是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们先引入一个vue文件，然后看看network</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23b294c3cf6f4f8c92937f9f93907336~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以发现script标签的src属性可以跨域,其实不止script标签可以跨域，还有<code>&lt;img&gt;</code> <code>&lt;link&gt;</code>标签。<br><br>jsonp的原理其实就是通过script标签的src属性来实现的。<br><br>我们来模拟实现一下，后端服务器用 <strong>koa2</strong> 搭建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端</span></span><br><span class="line">router.get(<span class="string">&#x27;/string&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;name,age&#125; = ctx.request.query</span><br><span class="line">  <span class="keyword">const</span> data = <span class="string">`我叫<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁！`</span></span><br><span class="line">  ctx.body = <span class="string">`func(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.src = <span class="string">&#x27;http://localhost:3000/string?name=leo&amp;age=30&amp;callback=func&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 我叫leo,今年30岁！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看src其实跟普通的get请求差不多，唯一就是多了个<strong>callback</strong>，而<strong>callback</strong>才是重点，其作用是为了接收接口请求回来的数据。<br><br>当我们执行完代码，可以发现控制台输出了后端返回给我们的数据，我们再看看f12的source，发现执行了该回调函数并带上了后端返回的数据给我们。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1356df6c9504aaaa84c3047a8f9f7fa~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这样就实现了跨域，整个过程其实就是前端定义回调函数，后端返回回调函数并带上数据。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote><p>需要前后端协商好回调函数命名，并且只支持get请求</p></blockquote><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h3><p><strong>跨域资源共享</strong>（Cross-Origin Resource Sharing）是一种机制，用来允许不同源服务器上的指定资源可以被特定的Web应用访问。<br><br>举个例子：如果A站的网页<code>a.com</code>访问B站网页<code>b.com</code>的API的时候，B站能够返回响应头<code>Access-Control-Allow-Origin: http://a.com</code>，那么，浏览器就允许A站的JavaScript访问B站的API。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端</span></span><br><span class="line"><span class="comment">// 使用koa-cors中间件 app.js</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>);</span><br><span class="line">app.use(cors())</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/string&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`我叫笨鸟`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端 http://localhost:8099/cross.html</span></span><br><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xmlhttp.responseText) <span class="comment">// 我叫笨鸟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://localhost:3000/string&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce236ed8ea884bc3ba9256977ace6a1b~tplv-k3u1fbpfcp-watermark.image" alt="1639327794(1).jpg"><br>浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。服务器会在返回的头部信息中添加<code>Access-Control-Allow-Origin</code>字段，浏览器会根据该字段与当前页面域名进行判断，如果一致就会放行。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote><p>CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p></blockquote><h3 id="3-websocket"><a href="#3-websocket" class="headerlink" title="3. websocket"></a>3. websocket</h3><p>WebSocket是一种在单个TCP连接上进行<strong>全双工通信</strong>的协议。<br><br>下面是一个websocket请求的的请求头</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad525da964c459a99e198ecdd718fef~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><code>Connection: Upgrade</code>：表示要升级协议</li><li><code>Upgrade: websocket</code>：表示要升级到websocket协议</li><li><code>Sec-WebSocket-Key</code>：与服务端响应的头部的Sec-webSocket-Accept是配套的，提供基本的防护，比如恶意链接或者无意链接</li><li><code>Sec-WebSocket-Version</code>：websocket版本，如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader,里面包含服务端支持的版本号。</li></ul><p><strong>websocket为什么没有同源限制？</strong><br><br>因为websocket使用类似ws://这样的方式进行连接，并不是使用http协议进行数据传输。所以浏览器的SOP无法限制它。而且websocket本来就是设计成支持跨域访问的协议的。在websocket请求的请求头中会像cors一样加入origin字段，服务端可以根据这个字段来判断是否通过该请求。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端 ws.js（需要通过node ws.js 命令启动服务）</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">3888</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 监听接口</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;socket start&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">ws.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">  client.send(<span class="string">&#x27;连接成功&#x27;</span>)</span><br><span class="line">  client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="built_in">JSON</span>.parse(msg.toString())</span><br><span class="line">    client.send(<span class="string">`我叫<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁`</span>) <span class="comment">// 通过send方法来给前端发送消息</span></span><br><span class="line">  &#125;)</span><br><span class="line">  client.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;关闭服务器连接&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;button onclick=<span class="string">&quot;send()&quot;</span>&gt;发送消息&lt;/button&gt;</span><br><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:3888/&quot;</span>) <span class="comment">// 监听地址端口号</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器连接&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">ws.onmessage= <span class="function">(<span class="params">msg</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg.data)</span><br><span class="line">&#125; </span><br><span class="line">ws.onclose=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器关闭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = &#123;</span><br><span class="line">    name: <span class="string">&#x27;笨鸟&#x27;</span>,</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">  &#125;</span><br><span class="line">  ws.send(<span class="built_in">JSON</span>.stringify(msg))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10e4c459521e447394f150ddf3386c1d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="4-postMessage"><a href="#4-postMessage" class="headerlink" title="4. postMessage"></a>4. postMessage</h3><p><strong>postMessage()</strong> 方法允许来自不同源的脚本采用异步方式进行有效的通信，可以实现跨文本文档，多窗口，跨域消息传递。多用于窗口间数据通信，这也使它成为跨域通信的一种有效的解决方案。<br><br>简而言之，可以<strong>跨域实现两个网页间的通讯</strong><br><br>我在网上搜到关于postMessage原理和应用场景<a href="https://blog.csdn.net/rongliang_chen/article/details/109840093">写的比较好的文章</a></p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><blockquote><ul><li>首先，信息传递安全问题。为了你的信息传递能准确传达，无论是作为主页面还是子页面，传递重要信息时都应该填写 origin 而不是 “*”，避免被截获。</li><li>其次，iframe 或者 window.open 的 load 事件是不准确的。为了避免漏发漏接的情况，建议在通讯页面里回传加载状态。</li></ul></blockquote><p><strong>a页面</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8099/a.html</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  我是a页面</span><br><span class="line">  &lt;div id=<span class="string">&quot;recMessage&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> messageEle = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;recMessage&#x27;</span>);</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  <span class="comment">// 监听 message 事件</span></span><br><span class="line">    <span class="keyword">if</span> (e.origin !== <span class="string">&quot;http://localhost:8848&quot;</span>) &#123;  <span class="comment">// 验证消息来源地址</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    messageEle.innerHTML = <span class="string">&quot;从&quot;</span>+ e.origin +<span class="string">&quot;收到消息： &quot;</span> + e.data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>b页面</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8848/b.html</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    我是b页面</span><br><span class="line">      &lt;iframe id=<span class="string">&quot;receiver&quot;</span> src=<span class="string">&quot;http://localhost:8099/a.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">      &lt;button id=<span class="string">&quot;sendMessage&quot;</span>&gt;发送信息&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> receiver = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;receiver&#x27;</span>).contentWindow;</span><br><span class="line">  <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;sendMessage&#x27;</span>);</span><br><span class="line">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    receiver.postMessage(<span class="string">&quot;Hello！我是来自8848端口的b页面&quot;</span>,<span class="string">&#x27;http://localhost:8099&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cb42f9b0a87458298f742f71e346db4~tplv-k3u1fbpfcp-watermark.image" alt="postmessage.png"></p><h3 id="5-node中间件代理"><a href="#5-node中间件代理" class="headerlink" title="5. node中间件代理"></a>5. node中间件代理</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong></p><ul><li>  接受客户端请求 。</li><li>  将请求 转发给服务器。</li><li>  拿到服务器 响应 数据。</li><li>  将 响应 转发给客户端。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19d3e1fe9c88417eaa28456a8cb3d2ea~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="1-非vue框架的跨域"><a href="#1-非vue框架的跨域" class="headerlink" title="1) 非vue框架的跨域"></a>1) 非vue框架的跨域</h4><p><code>koa2 + node + koa-server-http-proxy</code><br><br>koa-server-http-proxy相当于http-proxy-middleware的koa版本<br><br><strong>前端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xmlhttp.responseText) <span class="comment">// 我叫笨鸟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://localhost:3000/string&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>后端1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:3000</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;koa-better-http-proxy&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line">app.use(cors())</span><br><span class="line">app.use(</span><br><span class="line">  proxy(<span class="string">&#x27;127.0.0.1&#x27;</span>, &#123;</span><br><span class="line">    port: <span class="number">3001</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>后端2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:3001</span></span><br><span class="line">router.get(<span class="string">&#x27;/string&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`我叫笨鸟`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-vue框架的跨域"><a href="#2-vue框架的跨域" class="headerlink" title="2) vue框架的跨域"></a>2) vue框架的跨域</h4><p>平时我们用脚手架搭建的vue项目，为啥在webpack.config.js配置文件配置proxy参数就可以实现代理？<br></p><blockquote><p>当你运行项目的时候，会配置启动一个<code>node</code>服务，这个服务的作用1是静态文件服务，让你可以访问到<code>html/js</code>等文件包括监听文件变动等；2是启动一个http代理，你js发送的请求会请求到这个服务A，由服务A代理到服务B，而服务A和静态文件服务器是同源的，并不影响同源策略。<br>脚手架的代理<br><code>vue-cli</code>的<code>proxyTable</code>用的是<code>http-proxy-middleware</code>中间件<br><br><code>create-react-app</code>用的是<code>webpack-dev-server</code>内部也是用的<code>http-proxy-middleware</code><br></p></blockquote><p>webpack.config.js部分配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            target: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            secure: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            cookieDomainRewrite: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-nginx-反向代理"><a href="#6-nginx-反向代理" class="headerlink" title="6. nginx 反向代理"></a>6. nginx 反向代理</h3><p>实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。<br><br>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>nginx配置(<code>nginx -s reload</code>启动nginx)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">    listen       8888;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:3001;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:3001</span></span><br><span class="line">router.get(<span class="string">&#x27;/string&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`我叫笨鸟`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>前端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xmlhttp.responseText) <span class="comment">// 我叫笨鸟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://localhost:8888/string&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案</li><li>  JSONP 只支持 GET 请求，JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</li><li>  不管是 Node 中间件代理还是 nginx 反向代理，主要是通过同源策略对服务器不加限制。</li><li>  日常工作中，用得比较多的跨域方案是 cors 和 nginx 反向代理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;跨域&quot;&gt;&lt;a href=&quot;#跨域&quot; class=&quot;headerlink&quot; title=&quot;跨域&quot;&gt;&lt;/a&gt;跨域&lt;/h2&gt;&lt;p&gt;跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的&lt;strong&gt;同源策略&lt;/strong&gt;造成的，是浏览器对javascript施加</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的继承</title>
    <link href="http://example.com/2021/12/02/js-inherit/"/>
    <id>http://example.com/2021/12/02/js-inherit/</id>
    <published>2021-12-01T16:14:24.000Z</published>
    <updated>2021-12-15T14:52:03.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><p>其基本思想是<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>。<br><br>构造函数、原型和实例之间的关系：<strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</strong><br><br>大家可以根据下面这张图片，并结合上面这句话一起理解原型链，这里就不详细描述了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b79b2714cf942db91ee0561d36a6612~tplv-k3u1fbpfcp-zoom-1.image"></p><p>来看看原型链继承的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.property; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">     <span class="built_in">this</span>.subproperty = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 继承了 SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.subproperty; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>让我们看最关键的代码：<strong>SubType.prototype = new SuperType()</strong><br><br>为什么这一段代码就实现了继承？<br><br>我们先来看看new操作符的原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function create(Con, ...args) &#123;</span><br><span class="line">      let obj &#x3D; &#123;&#125;</span><br><span class="line">      obj.__proto__ &#x3D; Con.prototype</span><br><span class="line">      let result &#x3D; Con.apply(obj, args)</span><br><span class="line">      return result instanceof Object ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取出new的关键代码：<strong>obj.<strong>proto</strong> = Con.prototype</strong>，并将其嵌套在原型链继承的关键代码中，其实就是<strong>SubType.prototype.<strong>proto</strong> = SuperType.prototype</strong>。</p><p>根据上述的推理我们可以画出如下关系图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea69ea9a51654dcb9338a58cd1f3ec56~tplv-k3u1fbpfcp-watermark.image" alt="proto.PNG"><br>我们来验证一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(instance.__proto__ &#x3D;&#x3D;&#x3D; SubType.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(SubType.prototype.__proto__ &#x3D;&#x3D;&#x3D; SuperType.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>可以发现与我们的猜想成立。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure><p>为什么会这样？<br><br>因为通过原型链继承之后，<strong>SubType.prototype</strong>相当于<strong>Super</strong>的一个实例。当我们创建一个<strong>SubType</strong>的实例的时候，相当于创建了一个<strong>SubType.prototype.colors</strong>，当你更改color的时候其实就是更改<strong>SubType</strong>原型上的colors,所以导致<strong>SubType</strong>的原型属性会被所有实例共享。</p><h2 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2. 借用构造函数继承"></a>2. 借用构造函数继承</h2><p>基本思想：<strong>在子类型构造函数的内部调用超类型构造函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 继承了 SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure><p>实际上是在新创建的 SubType 实例的环境下调用了 SuperType 构造函数</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote><ol><li>父类的引用属性不会被共享</li><li>可以在子类构造函数中向父类传参数</li></ol></blockquote><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><blockquote><p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。达不到复用</p></blockquote><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>定义：将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。<br><br>基本思想：<strong>是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 继承属性，第二次继承</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法,第一次继承</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>将公共方法<strong>sayName</strong>挂载在父类（SuperType）的<strong>原型</strong>上，通过<strong>原型链继承</strong>就可以调用该方法，并且得到了复用。<br><br>为防止实例属性被共用，通过借用构造函数来继承<br></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><blockquote><p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript 中最常用的继承模式。</p></blockquote><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08bc24d92bae4976b37209725bfd83e9~tplv-k3u1fbpfcp-watermark.image" alt="zuhe.png"></p><p>结合上图，发现创建的实例和原型上存在两份相同的属性<br><br>这样的话会有什么问题吗？我举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> instance1.colors</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors) <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure><p>看上图，可以发现当我们删除实例的colors属性的时候，再去查询的时候，实际上还能访问到，但我们的意愿是访问把到。有值是因为原型上还有colors。<br></p><blockquote><p><strong>缺点：都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。导致其原型中会存在两份相同的属性/方法。</strong></p></blockquote><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h2><p><strong>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">    F.prototype = o; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本质上讲object()对传入其中的对象执行了一次潜复制</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; </span><br><span class="line">    name: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">    friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person); </span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person); </span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>; </span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。<br><br>缺点不多赘述跟原型链的缺点一样。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p><strong>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone &#x3D; object(original); &#x2F;&#x2F; 通过调用函数创建一个新对象 </span><br><span class="line">    clone.sayHi &#x3D; function()&#123; &#x2F;&#x2F; 以某种方式来增强这个对象 </span><br><span class="line">        console.log(&quot;hi&quot;); </span><br><span class="line">    &#125;;</span><br><span class="line">    return clone; &#x2F;&#x2F;返回这个对象 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; &#123; </span><br><span class="line">    name: &quot;Nicholas&quot;, </span><br><span class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;] </span><br><span class="line">&#125;; </span><br><span class="line">var anotherPerson &#x3D; createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); &#x2F;&#x2F;&quot;hi&quot;</span><br></pre></td></tr></table></figure><p>该继承与原型式继承紧密相关，在其基础上添加自己的属性/方法</p><h4 id="缺点（同原型式继承）"><a href="#缺点（同原型式继承）" class="headerlink" title="缺点（同原型式继承）"></a>缺点（同原型式继承）</h4><blockquote><p>与构造函数模式类似，添加的方法得不到复用，降低效率</p></blockquote><h2 id="5-寄生组合式继承"><a href="#5-寄生组合式继承" class="headerlink" title="5. 寄生组合式继承"></a>5. 寄生组合式继承</h2><p>组合继承会调用两次超类型构造函数，而寄生组合式继承可以完美的解决该问题。<br><br>基本思想：<strong>使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">    F.prototype = o; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.constructor = subType; <span class="comment">// 增强对象</span></span><br><span class="line">    subType.prototype = prototype; <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.name = name; </span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name); </span><br><span class="line">    <span class="built_in">this</span>.age = age; </span><br><span class="line">&#125; </span><br><span class="line">inheritPrototype(SubType, SuperType); </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line">instance1.sayName()</span><br><span class="line">instance1.colors.push(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance1.colors.push(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<strong>inheritPrototype</strong>函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。<br><br>从创建对象那一步，一开始感觉F函数和Super函数差不多，具体看看<code>object(SuperType.prototype)</code>和<code>new SuperType()</code>的区别</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28b8dca2249340e282ad039af338db3d~tplv-k3u1fbpfcp-watermark.image" alt="jszh.png"></p><p>可以发现两者是有区别的，使用一个空对象（F）作为中介的好处就是不会复制Super的属性，这样就避免了存在两份一样的属性<br></p><p><strong>我的大致理解</strong></p><blockquote><ul><li><ol><li>创建一个空对象（F）作为中介，让其原型指向与<strong>SuperType</strong>指向相同，避免了存在两份一样的属性</li></ol></li><li><ol start="2"><li>再通过原型链继承让<strong>subType</strong>的原型等于F的实例，继承<strong>SuperType</strong>原型上的属性/方法，避免创建实例的时候重复创建。</li></ol></li><li><ol start="3"><li>最后在创建实例的时候使用构造函数模式继承父类的属性</li></ol></li></ul></blockquote><p><strong>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js继承&quot;&gt;&lt;a href=&quot;#js继承&quot; class=&quot;headerlink&quot; title=&quot;js继承&quot;&gt;&lt;/a&gt;js继承&lt;/h1&gt;&lt;h2 id=&quot;1-原型链继承&quot;&gt;&lt;a href=&quot;#1-原型链继承&quot; class=&quot;headerlink&quot; title=&quot;1. </summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="protptype" scheme="http://example.com/tags/protptype/"/>
    
  </entry>
  
  <entry>
    <title>vue2的双向绑定原理实现</title>
    <link href="http://example.com/2021/11/27/vue2-code/"/>
    <id>http://example.com/2021/11/27/vue2-code/</id>
    <published>2021-11-27T06:38:31.000Z</published>
    <updated>2021-11-28T16:05:38.894Z</updated>
    
    <content type="html"><![CDATA[<p><img src="mvvm.gif" alt="mvvm"><br>先丢个效果图，本人前端菜鸟一枚，只是实现了一个简单的demo，有很多瑕疵，和考虑不周到的地方，欢迎大家提出建议。</p><p>先看个大致原理<strong>流程图</strong>，图片是从前端攻城狮大佬那里复制的。下面会一步步根据流程图一块块解析。<br><img src="mvvm.png" alt="mvvm"></p><h2 id="1-实现数据劫持"><a href="#1-实现数据劫持" class="headerlink" title="1. 实现数据劫持"></a>1. 实现数据劫持</h2><p>相信大家都知道vue2的双向绑定的原理是通过 <strong>Object.defineProperty()</strong> 来实现数据劫持的。<br>那什么是数据劫持呢？具体是怎么劫持的呢？<br><strong>数据劫持</strong> ：指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。<br>那我们来继续看看 <strong>Object.defineProperty()</strong> 怎么实现数据劫持的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>,&#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">  &#125;,</span><br><span class="line">  set (newVal) &#123;</span><br><span class="line">    name = newVal</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;obj的name属性值被更改了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line">obj.name = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br></pre></td></tr></table></figure><p><img src="def.png" alt="defineProperty"><br>可以发现在获取obj.name的时候我们可以设置返回的值，以及在更改obj的name属性值的时候我们也可以知道属性被赋值的操作。这样就实现了对数据的劫持。<br>但是我们在开发的时候，data里可能有多个变量，以及一个变量可能有多层的结构，那么我们怎么去监听所有变量呢？<br>这个时候我们就得对所有的变量执行 <strong>defineProperty()</strong> 方法，这样每一个变量值变更的时候我们都能知道。<br>话不多说，直接上代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  observe(val); <span class="comment">// 递归遍历所有子属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;属性&#x27;</span> + key + <span class="string">&#x27;已经被监听了，现在值为：“&#x27;</span> + newVal.toString() + <span class="string">&#x27;”&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    defineReactive(data, key, data[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;张&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;三&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">observe(obj)</span><br><span class="line">obj.name.firstName = <span class="string">&#x27;李&#x27;</span></span><br><span class="line">obj.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><p><img src="all-def.png" alt="递归数据劫持"></p><p>可以发现通过<strong>递归</strong>实现了变量的所有属性和值的监听</p><hr><h2 id="2-实现订阅器"><a href="#2-实现订阅器" class="headerlink" title="2. 实现订阅器"></a>2. 实现订阅器</h2><p>我们在上面实现了数据劫持，那这个时候我们只需要在变量进行变更的时候去通知视图更新。<br>订阅器的作用就是收集订阅者，在属性变化的时候告诉订阅者。比如我们很喜欢看某个公众号的文章，但是我们不知道什么时候发布新文章，要不定时的去翻阅；这时候，我们可以关注该公众号，当有文章推送时，会有消息及时通知我们文章更新了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  addSub (watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通知订阅者</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> &#123;</span><br><span class="line">      watcher.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 截取部分代码</span></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (是否需要添加订阅者) &#123;</span><br><span class="line">      dep.addSub(watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    val = newVal;</span><br><span class="line">    dep.notify()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;属性&#x27;</span> + key + <span class="string">&#x27;已经被监听了，现在值为：“&#x27;</span> + newVal.toString() + <span class="string">&#x27;”&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在改变变量值的时候，让订阅器的告诉订阅者该变量变更了，让订阅者执行相应的视图更新操作。</p><hr><h2 id="3-实现订阅者"><a href="#3-实现订阅者" class="headerlink" title="3. 实现订阅者"></a>3. 实现订阅者</h2><p>看上面的代码可以发现if条件里是文字描述，所以在什么时机去添加订阅者呢？<br>如果时机不对可能会频繁的添加重复的订阅，所以在变量初始化的时候就是最好的时机。<br>在变量初始化的时候，<strong>先缓存订阅者，然后触发get方法，将订阅者添加进订阅器，再把缓存清空。</strong>所以只要缓存不为空就添加订阅者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.vm = vm <span class="comment">// this</span></span><br><span class="line">  <span class="built_in">this</span>.exp = exp <span class="comment">// key</span></span><br><span class="line">  <span class="built_in">this</span>.cb = cb <span class="comment">// callback</span></span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.get() <span class="comment">// 初始化</span></span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">const</span> oldVal = <span class="built_in">this</span>.value</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.vm.data[<span class="built_in">this</span>.exp]</span><br><span class="line">    <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="built_in">this</span>.cb(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  get () &#123;</span><br><span class="line">    Dep.target = <span class="built_in">this</span> <span class="comment">// 缓存自己</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.vm.data[<span class="built_in">this</span>.exp]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// observer里的if判断</span></span><br><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      dep.push(Dep.target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="4-实现模板解析"><a href="#4-实现模板解析" class="headerlink" title="4. 实现模板解析"></a>4. 实现模板解析</h2><p>这个时候已经实现了observer和watcher的关联，那么哪一些是需要视图更新？<br>一般在我们开发dom数据里的变量可能是我们需要更新的视图，那么我们就需要去解析dom节点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码是不是很熟悉，我们这里就简单的实现一个解析器，解析模板数据 <strong></strong> 符号，只考虑大括号里存在一种变量的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileElement</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> childNodes = el.childNodes</span><br><span class="line">  childNodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text = node.textContent</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123; <span class="comment">// 如果是element</span></span><br><span class="line">      compileElement(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(text)) &#123; <span class="comment">// 文本内容</span></span><br><span class="line">      <span class="built_in">console</span>.log(reg.exec(text)[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">compileElement(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="complie.PNG" alt="模板解析"><br>我们用上面的代码解析上面的模板数据，可以发现我们已经实现可以解析出模板数据里的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>, </span><br><span class="line">  data:&#123;</span><br><span class="line">      count:<span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来我们还需要优化一下compile,可以看到el的传入形式，所以我们需要改一下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Compile (el,vm) &#123;</span><br><span class="line">  this.el &#x3D; document.querySelector(el)</span><br><span class="line">  this.vm &#x3D; vm</span><br><span class="line">  this.compileElement(this.el)</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype &#x3D; &#123;</span><br><span class="line">  compileElement (el) &#123;</span><br><span class="line">    let childNodes &#x3D; el.childNodes</span><br><span class="line">    const _self &#x3D; this</span><br><span class="line">    childNodes.forEach(node &#x3D;&gt; &#123;</span><br><span class="line">      let text &#x3D; node.textContent</span><br><span class="line">      const reg &#x3D; &#x2F;\&#123;\&#123;(.*)\&#125;\&#125;&#x2F;;</span><br><span class="line">      if (node.nodeType &#x3D;&#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果是element</span><br><span class="line">        _self.compileElement(node)</span><br><span class="line">      &#125;</span><br><span class="line">      else if (node.nodeType &#x3D;&#x3D;&#x3D; 3 &amp;&amp; reg.test(text)) &#123; &#x2F;&#x2F; 文本内容</span><br><span class="line">        const exp &#x3D;  reg.exec(text)[1]</span><br><span class="line">        const value &#x3D; this.vm.data[exp]</span><br><span class="line">        node.textContent &#x3D; value &#x2F;&#x2F; 将初始化的数据初始化到视图中</span><br><span class="line">        new Watcher(this.vm,exp,(val) &#x3D;&gt; &#123;</span><br><span class="line">          node.textContent &#x3D; val</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>模板的解析已经简单的实现了，接下来我们来定义一下vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myVue</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = option.data</span><br><span class="line">  observe(<span class="built_in">this</span>.data)</span><br><span class="line">  <span class="keyword">new</span> Compile(option.el,<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selfVue = myVue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="mvvm.gif" alt="mvvm"></p><p>可以看到我们通过控制台直接改变变量值，可以实现同步更新视图。<br>大部分都是参考前端攻城狮的<a href="https://www.cnblogs.com/canfoo/p/6891868.html">文章</a>，写的非常好。之前总有一些点没看懂，多看几遍，终于看懂了，并自己手敲实现了一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;mvvm.gif&quot; alt=&quot;mvvm&quot;&gt;&lt;br&gt;先丢个效果图，本人前端菜鸟一枚，只是实现了一个简单的demo，有很多瑕疵，和考虑不周到的地方，欢迎大家提出建议。&lt;/p&gt;
&lt;p&gt;先看个大致原理&lt;strong&gt;流程图&lt;/strong&gt;，图片是从前端攻城狮大</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>实现大文件切片上传，秒传，续传</title>
    <link href="http://example.com/2021/11/23/chunk-upload/"/>
    <id>http://example.com/2021/11/23/chunk-upload/</id>
    <published>2021-11-23T06:56:30.000Z</published>
    <updated>2021-11-27T09:18:43.230Z</updated>
    
    <content type="html"><![CDATA[<ul><li>大文件切片上传</li><li>秒传</li><li>断点续传</li></ul><h2 id="大文件的切片上传"><a href="#大文件的切片上传" class="headerlink" title="大文件的切片上传"></a>大文件的切片上传</h2><h3 id="1-大致流程"><a href="#1-大致流程" class="headerlink" title="1.大致流程"></a>1.大致流程</h3><ul><li><ol><li>将大文件切片</li></ol></li><li><ol start="2"><li>分别上传切片至后端</li></ol></li><li><ol start="3"><li>后端接收切片并存储在文件夹</li></ol></li><li><ol start="4"><li>合并切片成大文件，并删除切片和文件夹<br><img src="chunk.PNG" alt="切片上传流程"></li></ol></li></ul><h3 id="1-实现切片"><a href="#1-实现切片" class="headerlink" title="1. 实现切片"></a><strong>1. 实现切片</strong></h3><p>文件File的原型上提供了一个 <strong>slice</strong> 方法，通过这个方法可以对文件进行切割。以每5m分一个切片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span>  @change=<span class="string">&quot;handleFileChange&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        chunkList: [],</span><br><span class="line">        file: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileChange</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.file = e. target.files[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">this</span>.chunkList = createChunk(<span class="built_in">this</span>.file)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.chunkList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChunk</span> (<span class="params">file, size = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> chunks = []</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(cur &lt; file.size) &#123;</span><br><span class="line">        chunks.push(&#123;<span class="attr">file</span>:file.slice(cur,cur+size)&#125;)</span><br><span class="line">        cur += size</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> chunks</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我上传了个9.6m左右大小的文件，每片以5m分割，看log输出可以看到文件被切分成了两片，这样就实现了切片的效果<br><img src="slice.PNG" alt="切片"></p><h3 id="2-上传切片"><a href="#2-上传切片" class="headerlink" title="2. 上传切片"></a><strong>2. 上传切片</strong></h3><p>设置接口接收文件类型和进度条<br><strong>onUploadProgress</strong>是axios的进度条事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">param, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">        url: <span class="string">`/upload/file`</span>,</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        data: param,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onUploadProgress:cb</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>首先我们需要组装一下chunkList，将所需要的参数填充进去<br><font color='red'> 切片名称拼接索引， </font> 是为了后续续传的告诉前端已经上传的切片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillParams</span> (<span class="params">files, chunkList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> suffix = files.name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> fileName = files.name.slice(<span class="number">0</span>,suffix) <span class="comment">// 获取文件名称</span></span><br><span class="line">    <span class="keyword">let</span> chunkFile = chunkList.map( <span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">        file,</span><br><span class="line">        size: file.size,</span><br><span class="line">        percent: <span class="number">0</span>, <span class="comment">// 上传进度</span></span><br><span class="line">        chunkName: <span class="string">`<span class="subst">$&#123;fileName&#125;</span>-<span class="subst">$&#123;index&#125;</span>`</span>,</span><br><span class="line">        fileName: fileName,</span><br><span class="line">        index</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="keyword">return</span> chunkFile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>将所需的参数通过 <strong>FormData</strong> 传递给后端<br>其中 <strong>e.loaded</strong> 表示当前上传的数据大小，<strong>e.total</strong> 表示整个要上传的数据大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span> <span class="title">handleFileChange</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _self = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.file = e.target.files[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">this</span>.chunkList = fillParams(createChunk(<span class="built_in">this</span>.file))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reqList = <span class="built_in">this</span>.chunkList.map(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">        formData.append(<span class="string">&quot;file&quot;</span>, item.file)</span><br><span class="line">        formData.append(<span class="string">&quot;fileName&quot;</span>,  item.fileName)</span><br><span class="line">        formData.append(<span class="string">&quot;chunkName&quot;</span>,  item.chunkName)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            formData,</span><br><span class="line">            index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).map(<span class="function">(<span class="params">&#123;formData,index&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(formData,<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 设置每个切片的进度比  </span></span><br><span class="line">            _self.chunkList[index].percent =  <span class="built_in">parseInt</span>(<span class="built_in">String</span>((e.loaded / e.total) * <span class="number">100</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(reqList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-后端处理切片"><a href="#3-后端处理切片" class="headerlink" title="3. 后端处理切片"></a><strong>3. 后端处理切片</strong></h3><h4 id="将切片存储到文件夹中"><a href="#将切片存储到文件夹中" class="headerlink" title="将切片存储到文件夹中"></a><strong>将切片存储到文件夹中</strong></h4><p>后端的话我是用node的koa来模拟实现一下<br>上传的话通过<a href="https://www.cnblogs.com/wjlbk/p/12633320.html">koa-multer</a>中间件来实现。具体用法可以参考链接，这里就不贴出来啦。<br><strong>koa-multer</strong>中间件不能通过动态参数存储在动态路径，所以需要我们手动的去移动切片到文件夹中。<br><strong>fs.rename</strong>修改文件名称,更改文件的存放路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/file&#x27;</span>, upload.single(<span class="string">&#x27;file&#x27;</span>), <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> folderName = ctx.req.body.fileName <span class="comment">// 临时存储的文件夹名称（对应切片的fileName）</span></span><br><span class="line">  <span class="keyword">const</span> fileName = ctx.req.file.filename <span class="comment">// 中间件上传后切片的名称</span></span><br><span class="line">  <span class="keyword">const</span> chunkName = <span class="string">`<span class="subst">$&#123;ctx.req.body.chunkName&#125;</span>.<span class="subst">$&#123;ctx.req.file.originalname&#125;</span>`</span></span><br><span class="line">  <span class="keyword">const</span> folderPath = path.join(__dirname,<span class="string">`../../public/file/<span class="subst">$&#123;folderName&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// 判断文件夹是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!fs.existsSync(folderPath)) &#123;</span><br><span class="line">      fs.mkdir(folderPath, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> moveFile(fileName,folderName,chunkName)</span><br><span class="line">  ctx.success(fileName,<span class="string">&#x27;上传切片成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动文件</span></span><br><span class="line"><span class="keyword">const</span> moveFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">fileName,movePath,newFileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunkPath = path.join(__dirname, <span class="string">`../public/file/<span class="subst">$&#123;fileName&#125;</span>`</span>); <span class="comment">// 切片的路径</span></span><br><span class="line">  <span class="keyword">var</span> destPath = path.join(__dirname, <span class="string">`../public/file/<span class="subst">$&#123;movePath&#125;</span>`</span>, newFileName); </span><br><span class="line">  fs.rename(chunkPath, destPath, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>每个切片上传的size = 当前切片进度 * 当前切片size<br><strong>总进度 totalPercent = 每个切片上传的size ➗ 文件总size</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    totalPercent () &#123;</span><br><span class="line">        <span class="keyword">let</span> percent = <span class="built_in">this</span>.chunkList.map(<span class="function">(<span class="params">&#123;size,percent&#125;</span>) =&gt;</span> size * percent)</span><br><span class="line">            .reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>((percent/<span class="built_in">this</span>.file.size).toFixed(<span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="chunkUpload.gif" width="300" height="400" /><h3 id="4-合并切片"><a href="#4-合并切片" class="headerlink" title="4. 合并切片"></a><strong>4. 合并切片</strong></h3><p>切片上传完成之后，发送一个merge请求，让后端合并切片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeStream = <span class="function">(<span class="params">path, writeStream</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> readStream = fs.createReadStream(path);</span><br><span class="line">      readStream.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fs.unlinkSync(path); <span class="comment">// 删除切片</span></span><br><span class="line">          resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">      readStream.pipe(writeStream);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并切片 (filePath：将切片合并的路径)</span></span><br><span class="line"><span class="keyword">const</span> mergeFileChunk = <span class="keyword">async</span> (filePath, chunkName, size = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkDir = path.join(__dirname,<span class="string">`../public/file/<span class="subst">$&#123;chunkName&#125;</span>`</span>) <span class="comment">// 切片文件路径</span></span><br><span class="line">  <span class="keyword">let</span> chunkPaths = fs.readdirSync(<span class="string">`public/file/<span class="subst">$&#123;chunkName&#125;</span>`</span>)   <span class="comment">// 获取切片文件夹里所有切片</span></span><br><span class="line">  <span class="comment">// 根据切片索引进行排序，因为是异步请求所以文件顺序与文件读取顺序不一定一致</span></span><br><span class="line">  <span class="keyword">const</span> eq = <span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str.slice(str.lastIndexOf(<span class="string">&#x27;-&#x27;</span>)+<span class="number">1</span>,str.lastIndexOf(<span class="string">&#x27;.&#x27;</span>)))</span><br><span class="line">  chunkPaths.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> eq(a) - eq(b))</span><br><span class="line">  <span class="keyword">const</span> arr = chunkPaths.map(<span class="function">(<span class="params">chunk, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pipeStream(</span><br><span class="line">          path.resolve(chunkDir, chunk),</span><br><span class="line">          <span class="comment">// 指定位置创建可写流</span></span><br><span class="line">          fs.createWriteStream(filePath, &#123;</span><br><span class="line">              start: index * size,</span><br><span class="line">              end: (index + <span class="number">1</span>) * size</span><br><span class="line">          &#125;)</span><br><span class="line">      )</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(arr)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/mergeChunkFile&#x27;</span>, <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;fileName, chunkName&#125; = ctx.request.body</span><br><span class="line">  <span class="comment">// 存放切块的路径</span></span><br><span class="line">  <span class="keyword">const</span> mergePath = path.join(__dirname,<span class="string">`../../public/file/mergeFile/<span class="subst">$&#123;fileName&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">await</span> mergeFileChunk(mergePath,chunkName)</span><br><span class="line">  fs.rmdirSync(path.join(__dirname,<span class="string">`../../public/file/<span class="subst">$&#123;chunkName&#125;</span>`</span>)) <span class="comment">// 删除存储切片的文件夹</span></span><br><span class="line"> </span><br><span class="line">  ctx.success(fileName,<span class="string">&#x27;合并文件成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上传成功后，可以看到合并后的音乐已经存到了mergeFile文件夹了，并且切片文件夹已经删除。</p><p><img src="merge.PNG" alt="merge"></p><hr><h2 id="大文件秒传"><a href="#大文件秒传" class="headerlink" title="大文件秒传"></a>大文件秒传</h2><p>秒传的实现原理其实就是后端去校验文件是否已经上传，是的返回上传成功给前端。<br>秒传关键在于怎么校验文件是否已经上传？用文件名来校验肯定是不靠谱的，真实场景的话是通过文件的hash值来校验<br>那么前端怎么生成文件的hash值呢？<br>本篇是通过一个<a href="https://github.com/satazor/js-spark-md5">spark-md5</a>插件来生成的,具体用法可参考链接。<br>后端的话通过node的<strong>crypto</strong>模块生成文件的hash</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">&#x27;/verifyFile&#x27;</span>, <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;hash&#125; = ctx.request.body</span><br><span class="line">  <span class="keyword">const</span> shouldUpload = hasFile(hash)</span><br><span class="line"> ctx.success(&#123;shouldUpload&#125;,<span class="string">&#x27;校验成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件hash校验</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFile</span> (<span class="params">hash</span>) </span>&#123;</span><br><span class="line">  filePaths = fs.readdirSync(<span class="string">`public/file/mergeFile`</span>)</span><br><span class="line">  <span class="keyword">const</span> len = filePaths.length</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = createHash(filePaths[i])</span><br><span class="line">    <span class="keyword">if</span> (fileHash === hash)&#123;</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件hash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHash</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> buffer = fs.readFileSync(path.join(__dirname,<span class="string">`../public/file/mergeFile/<span class="subst">$&#123;fileName&#125;</span>`</span>));</span><br><span class="line">  <span class="keyword">const</span> fsHash = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">  fsHash.update(buffer);</span><br><span class="line">  <span class="keyword">const</span> md5 = fsHash.digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> md5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="大文件续传"><a href="#大文件续传" class="headerlink" title="大文件续传"></a>大文件续传</h2><p>续传的原理就是当一个大文件切分成了10个切片，上传了5个切片的时候被暂停了，点击续传的时候后端需要告诉前端已经上传的切片索引，前端再根据后端返回的索引并过滤掉他们从新请求未上传的切片<br><strong>思考：前端要怎么暂停请求？</strong><br><strong>CancelToken</strong>是axios提供取消ajax请求的，我们可以通过这个来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">&quot;pauseUpload&quot;</span>&gt;暂停&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">param, cb,cancelToken</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">        url: <span class="string">`/upload/file`</span>,</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        data: param,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onUploadProgress:cb,</span><br><span class="line">        cancelToken</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> source = CancelToken.source();</span><br><span class="line"><span class="comment">// 截取部分前面的请求代码</span></span><br><span class="line">map(<span class="function">(<span class="params">&#123;formData,index&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uploadFile(formData,<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        _self.chunkList[index].percent =  <span class="built_in">parseInt</span>(<span class="built_in">String</span>((e.loaded / e.total) * <span class="number">100</span>))</span><br><span class="line">    &#125;,source.token) <span class="comment">// 主要代码在这里</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停</span></span><br><span class="line"><span class="keyword">const</span> pauseUpload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    source.cancel(<span class="string">&quot;中断上传!&quot;</span>);</span><br><span class="line">    source = CancelToken.source(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>后端实现校验需要 文件夹的名称，切片总数字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uploadChunk已上传的切片索引</span></span><br><span class="line"><span class="keyword">const</span> filePath = path.join(__dirname,<span class="string">`../../public/file/<span class="subst">$&#123;chunkName&#125;</span>`</span>)</span><br><span class="line"><span class="keyword">if</span> (fs.existsSync(filePath)) &#123;</span><br><span class="line">     chunkFiles = fs.readdirSync(<span class="string">`public/file/<span class="subst">$&#123;chunkName&#125;</span>`</span>)</span><br><span class="line">     <span class="keyword">if</span> (chunkFiles.length &lt; chunkLen) &#123;</span><br><span class="line">        <span class="keyword">const</span> eq = <span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str.slice(str.lastIndexOf(<span class="string">&#x27;-&#x27;</span>)+<span class="number">1</span>,str.lastIndexOf(<span class="string">&#x27;.&#x27;</span>)))</span><br><span class="line">        <span class="keyword">const</span> uploadChunk = chunkFiles.map(<span class="function"><span class="params">item</span> =&gt;</span> eq(item))</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端根据后端返回的索引，进行过滤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunkList.filter(<span class="function"><span class="params">item</span> =&gt;</span> !uploadChunk.includes(item.index))</span><br></pre></td></tr></table></figure><p>来看看具体效果<br><img src="continueUpload.gif" width="300" height="400" /></p><p>大部分参考掘金作者三心的<a href="https://juejin.cn/user/1292681407377624">文章</a>实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;大文件切片上传&lt;/li&gt;
&lt;li&gt;秒传&lt;/li&gt;
&lt;li&gt;断点续传&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;大文件的切片上传&quot;&gt;&lt;a href=&quot;#大文件的切片上传&quot; class=&quot;headerlink&quot; title=&quot;大文件的切片上传&quot;&gt;&lt;/a&gt;大文件的切片上传</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="node" scheme="http://example.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>树组件实现虚拟滚动</title>
    <link href="http://example.com/2021/07/20/tree-inventScroll/"/>
    <id>http://example.com/2021/07/20/tree-inventScroll/</id>
    <published>2021-07-19T16:15:01.000Z</published>
    <updated>2021-11-28T16:06:13.504Z</updated>
    
    <content type="html"><![CDATA[<p><img src="invent.gif" alt="invent.gif"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>当数据过多时，渲染出现卡顿。因为 dom 数量过大。</li></ol><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul><li><ol><li>将树形数据和 dom 扁平化</li></ol></li><li><ol start="2"><li>虚拟长列表控制 dom 渲染数量</li></ol></li></ul><h3 id="1-扁平化"><a href="#1-扁平化" class="headerlink" title="1.扁平化"></a>1.扁平化</h3><p><img src="tree1.png" alt="扁平化tree的DOM结构图"></p><center>扁平化tree的DOM结构图-1</center>由上图可以看出经过扁平化处理后的父子节点dom是同级的，接下来我们来实现将tree数据扁平化处理。    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">&quot;课程1&quot;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-1&quot;</span> &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">5</span>,</span><br><span class="line">        title: <span class="string">&quot;课程1-2&quot;</span>,</span><br><span class="line">       children: [</span><br><span class="line">          &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-1&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-2&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&quot;课程2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&quot;课程3&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> flatData = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&quot;课程1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&quot;课程2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&quot;课程3&quot;</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将 treeData 的数据格式转变成 faltData,将数据<strong>扁平化</strong>的过程</p><h4 id="迭代和递归实现扁平化"><a href="#迭代和递归实现扁平化" class="headerlink" title="迭代和递归实现扁平化"></a>迭代和递归实现扁平化</h4><p>我们先来讲讲<strong>递归</strong>和<strong>迭代</strong>的异同。</p><ul><li>递归使用的是选择结构，能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。</li><li>迭代使用的是循环结构，不需要反复调用函数和占用额外的内存。因此我们应该视不同 情况选择不同的代码实现方式。<br>在算法中我们会遇到很多递归实现的案例，所有的递归都可以转换成非递归实现，其中转换的本质是：<font color="color"><strong>递归是解析器(引擎)来帮我们做了栈的存取，非递归是手动创建栈来模拟栈的存取过程</strong>。</font><br>下面我们通过<strong>栈</strong>来实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">faltten</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flatData = []</span><br><span class="line">  <span class="keyword">let</span> stack = [...tree]</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack.shift()</span><br><span class="line">    <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">      stack.unshift(...node.children)</span><br><span class="line">    &#125;</span><br><span class="line">    flatData.push(&#123; <span class="attr">id</span>: node.id, <span class="attr">title</span>: node.title &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flatData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们通过<strong>递归</strong>来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">faltten</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flatData = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    formatData.push(&#123;</span><br><span class="line">      id: data[i].id,</span><br><span class="line">      title: data[i].title,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (data[i].children) &#123;</span><br><span class="line">      formatData = formatData.concat(faltten(data[i].children))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> formatData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现扁平化的树型组件功能，我们的数据字段需要 <code>expand</code>，<code>visible</code>，<code>children</code>，<code>level</code> 字段。大致结构：<br><strong><font color="red"><br>{<br>&emsp;&emsp;key:<br>&emsp;&emsp;title:<br>&emsp;&emsp;level: 通过 level 标识节点层级，通过 css 实现层级的区别<br>&emsp;&emsp;visible: 节点的显示隐藏属性<br>&emsp;&emsp;expand: 展开状态<br>&emsp;&emsp;children: 存储子节点的引用，通过引用控制子节点的显示隐藏<br>}<br></font></strong><br>通过上面的分析，我们来继续实现新增字段之后的扁平化处理</p><p><strong>迭代</strong>实现方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">flatten () &#123;</span><br><span class="line">      <span class="keyword">let</span> flatData = []</span><br><span class="line">      <span class="keyword">let</span> stack = [...tree]</span><br><span class="line">      <span class="keyword">let</span> parentIndex = &#123;&#125; <span class="comment">// 存储level的索引</span></span><br><span class="line">      <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.shift()</span><br><span class="line">        <span class="keyword">if</span> (!node.level) &#123;</span><br><span class="line">          node.level = <span class="number">0</span></span><br><span class="line">          node.visible = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">          parentIndex[node.level] = flatData.length <span class="comment">// node的索引等于flatData的长度，因为接下来push的就是node</span></span><br><span class="line">          <span class="keyword">const</span> children = node.children.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="comment">// 设置子类的level</span></span><br><span class="line">            <span class="keyword">return</span> &#123;...item, <span class="attr">level</span>: node.level + <span class="number">1</span>, <span class="attr">visible</span>: node.expand&#125;&#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          stack.unshift(...children)</span><br><span class="line">        &#125;</span><br><span class="line">        flatData.push(&#123;...node, <span class="attr">children</span>: []&#125;)</span><br><span class="line">        <span class="keyword">if</span> (node.level !== <span class="number">0</span>) &#123; <span class="comment">// 添加子类引用（只要level不是第一层，node肯定有父节点）</span></span><br><span class="line">          flatData[parentIndex[node.level - <span class="number">1</span>]].children.push(flatData[flatData.length - <span class="number">1</span>]) <span class="comment">// 往当前的node的父节点的children属性添加本身</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> flatData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong>实现方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flatten (data, arr = [], parent = <span class="literal">null</span>, level = <span class="number">0</span>, visible = <span class="literal">true</span>, children = [], insert = <span class="literal">null</span>) &#123;</span><br><span class="line">      arr.push(&#123;...data, level, parent, visible, children&#125;)</span><br><span class="line">      <span class="keyword">if</span> (insert !== <span class="literal">null</span>) &#123;</span><br><span class="line">        arr[insert].children.push(arr[arr.length - <span class="number">1</span>]) <span class="comment">// 给父节点的children字段添加子节点引用</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (data.children) &#123;</span><br><span class="line">        insert = arr.length - <span class="number">1</span> <span class="comment">// 父节点插入子节点引用索引</span></span><br><span class="line">        data.children.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.flatten(item, arr, arr[arr.length - <span class="number">1</span>], level + <span class="number">1</span>, data.expand, [], insert)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>难点在于存储子节点的 data 引用，存储子节点的引用是因为子节点对象和 children 对象指向的是同一个内存地址，所以后续隐藏节点的时候，我们可以直接通过获取当前点击节点的 children 字段，进行 visible 属性的隐藏设置。</p><p><strong>扁平化数据的树型渲染</strong></p><p><strong>1.树型节点的遍历</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">    :key=&quot;i&quot;</span><br><span class="line">    class=&quot;tree-item&quot;</span><br><span class="line">    v-show=&quot;item.visible&quot;</span><br><span class="line">    @click=&quot;handleExpand(item)&quot;</span><br><span class="line">    v-for=&quot;(item, i) in unHiddenList.slice(startIndex, endIndex)&quot;</span><br><span class="line">    :style=&quot;`transform:translateX($&#123;item.level * 20&#125;px)`&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>节点的层级区别通过<strong>level</strong>属性来控制</p><p><strong>unHiddenList</strong>代表visible属性为false (即未展开) 的数据列表</p><p><strong>2.节点的展开和隐藏实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">handleExpand (node) &#123; <span class="comment">// 点击节点操作</span></span><br><span class="line">  <span class="keyword">const</span> status = !node.expand</span><br><span class="line">  node.expand = status</span><br><span class="line">  <span class="keyword">if</span> (status &amp;&amp; node.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node.children.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123; <span class="comment">// 将点击节点的子节点显示</span></span><br><span class="line">      item.visible = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">    <span class="built_in">this</span>.handleClose(node.children) <span class="comment">// 隐藏点击节点的子孙节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">handleClose (node) &#123; <span class="comment">// 隐藏节点</span></span><br><span class="line">  node.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.visible = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (item.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      item.expand = <span class="literal">false</span></span><br><span class="line">      <span class="built_in">this</span>.handleClose(item.children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h3><p><strong>dom大致结构</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;wrap&quot;</span> @<span class="attr">scroll</span>=<span class="string">&quot;handleScroll&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;invent-space&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;`height:$&#123;contentHeight&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 虚拟滚动高度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 节点遍历 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>contentHeight</strong>代表整个滚动的内容高度<br>*<em>contentHeight = unHiddenList.length * itemHeight(节点高度)*</em></p><p><strong>监听滚动事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">updateVisibleData (scrollTop = <span class="number">0</span>) &#123;</span><br><span class="line">  requestAnimationFrame(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scrollTop &lt; (<span class="built_in">this</span>.unHiddenList.length - <span class="number">20</span>) * <span class="built_in">this</span>.itemHeight) &#123; <span class="comment">// 小于可滚动距离（unHiddenList未隐藏的节点列表）</span></span><br><span class="line">      <span class="built_in">this</span>.$refs.list.style.transform = <span class="string">&#x27;translate3d(0,&#x27;</span> + scrollTop + <span class="string">&#x27;px,0)&#x27;</span> <span class="comment">// 同步滚动</span></span><br><span class="line">      <span class="built_in">this</span>.startIndex = <span class="built_in">Math</span>.floor(scrollTop / <span class="built_in">this</span>.itemHeight) <span class="comment">// 已滚动的节点数量</span></span><br><span class="line">      <span class="built_in">this</span>.endIndex = <span class="built_in">this</span>.startIndex + <span class="number">20</span> <span class="comment">// 已滚动的数量加可视区域的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的20代表的是可视item，25代表的是item的高度，数字可以根据需求自己设置。<br>其中使用<code>transform</code>来实现虚拟滚动的原因是由于 <code>transform</code> 是位于 <code>Composite Layers</code> 层，而 <code>width</code> 、 <code>left</code> 、 <code>margin</code> 等则是位于 <code>Layout</code> 层，在 <code>Layout</code> 层发生的改变必定导致 <code>Paint Setup and Paint</code>  -&gt;  <code>Composite Layers</code> ，所以相对而言使用 <code>transform</code> 实现的动画效果肯定比 <code>left</code> 这些更加流畅。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;invent.gif&quot; alt=&quot;invent.gif&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;当数据过多时，渲染出现卡顿。因为 </summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>http1.0/1.1/2.0区别</title>
    <link href="http://example.com/2021/03/23/http/"/>
    <id>http://example.com/2021/03/23/http/</id>
    <published>2021-03-23T15:40:51.000Z</published>
    <updated>2021-11-27T09:18:03.017Z</updated>
    
    <content type="html"><![CDATA[<ul><li>http1.0与http1.1区别</li><li>http2.0的特点</li><li>http1.1与http2.0区别</li><li>混淆的问题</li></ul><h2 id="http1-0与http1-1区别"><a href="#http1-0与http1-1区别" class="headerlink" title="http1.0与http1.1区别"></a>http1.0与http1.1区别</h2><ul><li><strong>长连接(Persistent Connection)</strong><blockquote><p>HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。<br><strong>HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为<font color="red">Keep-Alive</font>时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。</strong></p></blockquote></li><li><strong>节约带宽</strong><blockquote><p>HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p></blockquote></li><li><strong>HOST域</strong><blockquote><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</p></blockquote></li><li><strong>请求方法</strong><blockquote><p>HTTP1.1增加了<strong>OPTIONS</strong>，<strong>PUT</strong>，<strong>DELETE</strong>，<strong>TRACE</strong>，<strong>CONNECT</strong>的请求方法。</p></blockquote></li><li><strong>缓存处理</strong><blockquote><p>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如<strong>Entity tag，If-Unmodified-Since, If-Match, If-None-Match</strong>等更多可供选择的缓存头来控制缓存策略。</p></blockquote></li><li><strong>状态码</strong><blockquote><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></blockquote></li></ul><h2 id="http2-0的特点"><a href="#http2-0的特点" class="headerlink" title="http2.0的特点"></a>http2.0的特点</h2><ul><li><p><strong>二进制分帧层</strong><br>HTTP 2.0性能增强的核心，全在于新增的<strong>二进制分帧层</strong>，它定义了如何封装HTTP消息并在客户端与服务器之间传输。<br><img src="http4.jpg" alt="http"></p></li><li><p><strong>流、消息和帧</strong></p><ul><li><strong>流</strong>：已建立的连接的双向字节流</li><li><strong>消息</strong>：与逻辑消息对应的完整的一系列数据帧</li><li><strong>帧</strong>：HTTP2.0通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流</li></ul><p>所有HTTP 2.0通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。<br>每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。<br><img src="http5.jpg" alt="http"><br>简言之，HTTP 2.0把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。<br>相应地，很多流可以并行地在同一个TCP连接上交换消息。</p></li><li><p><strong>多向请求与响应</strong><br>在HTTP 1.x中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个TCP连接。<br>HTTP 2.0中的二进制分帧层突破了限制：客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。<br><img src="http6.jpg" alt="http"></p></li><li><p><strong>请求优先级</strong><br>每个HTTP2.0流里面有个优先值，这个优先值确定着客户端和服务器处理不同的流采取不同的优先级策略，高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。</p><h2 id="http1-1与http2-0区别"><a href="#http1-1与http2-0区别" class="headerlink" title="http1.1与http2.0区别"></a>http1.1与http2.0区别</h2></li><li><p><strong>多路复用</strong></p><blockquote><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p></blockquote></li></ul><p><img src="http2.jpg" alt="http"></p><ul><li><p><strong>头部数据压缩（<a href="https://imququ.com/post/header-compression-in-http2.html">深入了解头部压缩</a>）</strong></p><blockquote><p>在HTTP1.1中，HTTP请求和响应都是由<strong>状态行、请求/响应头部、消息主体</strong>三部分组成。一般而言，消息主体都会经过<strong>gzip压缩</strong>，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。<br>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。<br><img src="http.webp" alt="http"><br>HTTP 2.0连接的两端都知道已经发送了哪些首部，这些首部的值是什么，从而可以针对之前的数据只编码发送<strong>差异</strong>数据。头部数据通过字典存储(键值对)的形式进行存储<br><img src="http3.jpg" alt="http"></p></blockquote></li><li><p><strong>服务器推送</strong></p><blockquote><p>服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。<br>为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p></blockquote></li><li><p>普通的客户端请求过程：<br><img src="http_push.webp" alt="http"></p></li><li><p>服务端推送的过程：<br><img src="http_push1.webp" alt="http"></p></li></ul><h2 id="混淆的问题"><a href="#混淆的问题" class="headerlink" title="混淆的问题"></a>混淆的问题</h2><p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p><p>HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；<br>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；<br>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;http1.0与http1.1区别&lt;/li&gt;
&lt;li&gt;http2.0的特点&lt;/li&gt;
&lt;li&gt;http1.1与http2.0区别&lt;/li&gt;
&lt;li&gt;混淆的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;http1-0与http1-1区别&quot;&gt;&lt;a href=&quot;#htt</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>JS定时器不准确及解决方案</title>
    <link href="http://example.com/2021/02/09/js-setInterval/"/>
    <id>http://example.com/2021/02/09/js-setInterval/</id>
    <published>2021-02-09T07:12:45.000Z</published>
    <updated>2021-11-27T09:16:25.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><ul><li>浏览器中的所有JavaScript都在单线程上执行，所以异步事件（比如定时器）仅在线程空闲时才会被调度运行。</li><li>为了控制要执行的代码， JavaScript 配置了一个任务队列，这些异步事件任务会按照将它们添加到队列的顺序执行。</li><li>而setTimeout() 的第二个参数（延时时间）只是告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</li></ul><p><strong>因此定时器延迟是不能保证的。</strong></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="动态计算时差-（仅针对循环定时，只起修正作用-）"><a href="#动态计算时差-（仅针对循环定时，只起修正作用-）" class="headerlink" title="动态计算时差 （仅针对循环定时，只起修正作用 ）"></a>动态计算时差 （仅针对循环定时，只起修正作用 ）</h2><ul><li>在定时器开始前和运行时动态获取当前时间，在设置下一次定时时长时，在期望值基础上减去当前时延，以获得相对精准的定时运行效果。</li><li>此方法仅能消除setInterval()长时间运行造成的误差累计，但无法消除单个定时器执行延迟问题。</li></ul><p>注： 时差过大时，由于无法时间回流，只能按没有间隔处理，减轻影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//耗时任务</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">100000000</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">var</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">var</span> nextTime = <span class="number">1000</span> - offset;</span><br><span class="line">    <span class="keyword">if</span> (nextTime &lt; <span class="number">0</span>) nextTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(handle, nextTime);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">&#x27; --- &#x27;</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(handle, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用-Web-Worker"><a href="#使用-Web-Worker" class="headerlink" title="使用 Web Worker"></a>使用 Web Worker</h2><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//耗时任务</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">100000000</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker 解决方案</span></span><br><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">&#x27; --- &#x27;</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>)));</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;浏览器中的所有JavaScript都在单线程上执行，所以异步事件（比如定时器）仅在线程空闲时才会被调度运行。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>16进制颜色转换RGB原理</title>
    <link href="http://example.com/2020/12/28/js-rgba/"/>
    <id>http://example.com/2020/12/28/js-rgba/</id>
    <published>2020-12-28T03:59:48.000Z</published>
    <updated>2021-11-27T09:16:35.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RGB-三通道颜色"><a href="#RGB-三通道颜色" class="headerlink" title="RGB: 三通道颜色"></a>RGB: 三通道颜色</h2><ul><li>他是目前运用最广泛的颜色系统之一</li><li>可以通过红绿蓝三色通道, 外加alpha透明度, 来展示几乎所有的颜色</li><li>RGB是从颜色的发光原理来设定的, 相当于红绿蓝三个颜色通过不同亮度, 来组合成为需要的颜色</li><li>0为最暗, 255为最亮</li></ul><h2 id="RGB转换为HEX-16进制"><a href="#RGB转换为HEX-16进制" class="headerlink" title="RGB转换为HEX(16进制)"></a>RGB转换为HEX(16进制)</h2><p>RGB与HEX中每个颜色都是一一对应的关系<br><strong>RGB的数值 = 16 * HEX的第一位 + HEX的第二位</strong><br>示例如下:</p><ul><li>RGB: 92, 184, 232</li><li>92 / 16 = 5余12 -&gt; 5C</li><li>184 / 16 = 11余8 -&gt; B8</li><li>232 / 16 = 14余8 -&gt; E8</li><li>HEX = 5CB8E8</li></ul><h2 id="HEX转换RGB"><a href="#HEX转换RGB" class="headerlink" title="HEX转换RGB"></a>HEX转换RGB</h2><p>此转换就是将上述的转换逆转即可<br>示例如下</p><ul><li>HEX: F26BC1</li><li>F2 = 15和2 -&gt; 15 * 16 + 2 = 242</li><li>6B = 6和11 -&gt; 6 * 16 + 11 = 107</li><li>C1 = 12和1 -&gt; 12 * 16 + 1 = 193</li></ul><h2 id="常见算法题"><a href="#常见算法题" class="headerlink" title="常见算法题"></a>常见算法题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>设计一个函数，给出一个rgba数值，返回16进制的表达式及透明度。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p><strong>rgba(255,255,255,0.4)</strong></p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p><strong>颜色：#FFFFFF，透明度：0.4</strong></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = str.slice(<span class="number">5</span>,-<span class="number">1</span>).split(<span class="string">&#x27;,&#x27;</span>) <span class="comment">// 截取字符串</span></span><br><span class="line">    <span class="keyword">var</span> color = [<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">&#x27;颜色：#&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="built_in">Math</span>.floor((r[i]) / <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">let</span> y = <span class="built_in">Number</span>(r[i]) % <span class="number">16</span></span><br><span class="line">        res += color[c]</span><br><span class="line">        <span class="keyword">if</span>(y === <span class="number">0</span>) res += color[c]</span><br><span class="line">        <span class="keyword">else</span> res += color[y]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;res&#125;</span>，透明度：<span class="subst">$&#123;r[<span class="number">3</span>]&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RGB-三通道颜色&quot;&gt;&lt;a href=&quot;#RGB-三通道颜色&quot; class=&quot;headerlink&quot; title=&quot;RGB: 三通道颜色&quot;&gt;&lt;/a&gt;RGB: 三通道颜色&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;他是目前运用最广泛的颜色系统之一&lt;/li&gt;
&lt;li&gt;可以通过红绿蓝三</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="rgba" scheme="http://example.com/tags/rgba/"/>
    
  </entry>
  
  <entry>
    <title>变量提升和函数提升</title>
    <link href="http://example.com/2020/12/25/js-Hoisting/"/>
    <id>http://example.com/2020/12/25/js-Hoisting/</id>
    <published>2020-12-24T16:43:43.000Z</published>
    <updated>2021-11-27T09:17:03.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。<br>js怎么创建变量？<br><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>js在解析上面的代码的时候，其实会按照下面的方式进行解析的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>所以 js 并不是在我们定义一个变量的时候，声明完成之后立即赋值，而是把所有用到的变量全部声明之后，再到变量的定义的地方进行赋值，变量的声明的过程就是变量的提升。</p><p>现在我们来看看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>思考一下会输出什么？<br><strong>分析</strong><br>实际上的解析过程是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">var</span> b;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>变量在声明提升的时候，是全部提升到作用域的最前面，一个接着一个的。但是在变量赋值的时候就不是一个接着一个赋值了，而是<strong>赋值的位置</strong>在变量<strong>原本定义的位置</strong>。原本js定义变量的地方，在js运行到这里的时候，才会进行赋值操作，而没有运行到的变量，不会进行赋值操作。</p><p>所以变量的提升，<strong>提升的其实是变量的声明，而不是变量的赋值。</strong></p><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数的提升和变量的提升类似，都是提升到作用域的最开始的位置，只不过变量的提升是分两步的，第一步是变量声明的提升，第二步是变量的赋值。而函数的提升是直接将整个函数整体提升到作用域的最开始位置，相当于剪切过去的样子。</p><h3 id="同名方法"><a href="#同名方法" class="headerlink" title="同名方法"></a>同名方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>解析过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo2</span></span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p><strong>在js里同时有两个同名函数方法时，会默认调用最后一个同名方法</strong></p><h3 id="同名的函数表达式"><a href="#同名的函数表达式" class="headerlink" title="同名的函数表达式"></a>同名的函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>解析过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo1</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p><strong>实质是变量提升的过程</strong></p><h3 id="变量提升和函数提升的顺序"><a href="#变量提升和函数提升的顺序" class="headerlink" title="变量提升和函数提升的顺序"></a>变量提升和函数提升的顺序</h3><p>在作用域中，不管是变量还是函数，都会提升到作用域最开始的位置<br><strong>函数提升优先级高于变量提升，且不会被变量声明覆盖，但会被变量赋值覆盖（重点）</strong><br>举个例子：<br>下面的代码输出什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码在js眼中是这样解析的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a()</span></span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>所以从上面的例子可以看出如果函数提升会被变量声明覆盖的话，则第一个console.log(a)就等于undefined。</p><p>我们再来看一个例子，看看num等于多少</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num=foo(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>思考1分钟，觉得num等于多少？<br>实际上的解析过程是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line">num = foo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>印证了函数提升不会被变量声明覆盖，但会被变量赋值覆盖</strong></p><p>最后注意：只有声明的变量和函数才会进行提升，<strong>隐式全局变量不会提升</strong>。</p><p>下面的栗子中，b不会进行变量提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 报错 Uncaught ReferenceError: b is not defined</span></span><br><span class="line">  b = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h2&gt;&lt;p&gt;通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="var" scheme="http://example.com/tags/var/"/>
    
    <category term="function" scheme="http://example.com/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>前端持久化存储</title>
    <link href="http://example.com/2020/12/23/js-storage/"/>
    <id>http://example.com/2020/12/23/js-storage/</id>
    <published>2020-12-23T12:16:04.000Z</published>
    <updated>2021-11-27T09:16:16.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul><li><strong>定义：</strong><br>Cookie是保存在客户机的文本文件（IE保存在本地的一个txt文件中）, 这个文件与特定的 Web 文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用。请求服务器时放在http请求头里面（不论是否需要，都会放在请求头里面）</li><li><strong>为什么需要cookie？</strong><br>HTTP是一种无状态的协议，客户端与服务器建立连接并传输数据，数据传输完成后，连接就会关闭。再次交互数据需要建立新的连接，因此，服务器无法从连接上跟踪会话，也无法知道用户上一次做了什么。如：在网络有时候需要用户登录才进一步操作，用户输入用户名密码登录后，浏览了几个页面，由于HTTP的无状态性，服务器并不知道用户有没有登录。但是有了Cookie，服务器在第一次客户端请求的时候，将cookie保存在客户端，客户端重新请求服务器时会携带cookie（未过期），这样服务器就知道上一次用户做了什么。服务器还会对Cookie信息进行维护，必要时会对Cookie内容进行修改。</li><li><strong>场景：</strong><blockquote><p><strong>保存用户登录状态</strong>：例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。<br><strong>跟踪用户行为</strong>：例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。<br><strong>定制页面</strong>：如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。<br><strong>创建购物车</strong>：正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。 </p></blockquote></li><li><strong>属性：</strong><table><thead><tr><th align="center">序号</th><th align="center">属性</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Expires(http/1.0协议)</td><td align="left">设置Cookie的过期时间</td></tr><tr><td align="center">2</td><td align="center">maxAge(http/1.1协议)</td><td align="left">该Cookie失效的时间，单位秒。是个相对值,相对的是文档第一次被请求时服务器记录的请求时间。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，关闭浏览器即失效。如果为0，表示删除该Cookie。默认为–1。</td></tr><tr><td align="center">3</td><td align="center">path</td><td align="left">cookie能被使用的路径，默认当前路径 /</td></tr><tr><td align="center">4</td><td align="center">domain</td><td align="left">该Cookie变量所属域</td></tr><tr><td align="center">5</td><td align="center">Secure</td><td align="left">指定是否使用HTTPS安全协议发送Cookie。在网络上传输数据之前先将数据加密。默认为false</td></tr><tr><td align="center">6</td><td align="center">httpOnly</td><td align="left">设置cookie是否能通过 js 去访问,防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。默认为false</td></tr><tr><td align="center">7</td><td align="center">size</td><td align="left">cookie的大小</td></tr></tbody></table></li><li><strong>缺点：</strong></li><li>每个特定域名下的cookie数量有限</li><li>存储量太小，只有4KB；</li><li>每次HTTP请求都会发送到服务端，影响获取资源的效率；</li><li>需要自己封装获取、设置、删除cookie的方法；</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>html5 中的 Web Storage 包括了两种存储方式：<strong>sessionStorage</strong> 和<strong>localStorage</strong>。<br><strong>sessionStorage</strong> 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据也随之销毁。<br><strong>localStorage</strong> 用于存储一个域名下的需要永久存在在本地的数据，这些数据可以被一直访问，直到这些数据被删除。<br>因此sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage 存储的数据的生命周期是永久，直到被主动删除，否则数据永远不会过期的。</p><h3 id="sessionStorage-和-localStorage异同"><a href="#sessionStorage-和-localStorage异同" class="headerlink" title="sessionStorage 和 localStorage异同"></a>sessionStorage 和 localStorage异同</h3><ul><li><strong>生命周期</strong>：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。  sessionStorage的生命周期是在仅在当前会话下有效。</li><li><strong>存储大小</strong>：localStorage和sessionStorage的存储数据大小一般都是：5MB  </li><li><strong>存储位置</strong>：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。  </li><li><strong>存储内容类型</strong>：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理  </li><li><strong>获取方式</strong>：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。 </li><li> <strong>应用场景</strong>：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据（令牌）。sessionStorage：敏感账号一次性登录；</li></ul><h2 id="web-storage和cookie的异同"><a href="#web-storage和cookie的异同" class="headerlink" title="web storage和cookie的异同"></a>web storage和cookie的异同</h2><p><strong>共同点：</strong><br><strong>都是保存在浏览器端，且同源的。</strong></p><p><strong>区别：</strong></p><ul><li>存储的大小：cookie：单个cookie保存的数据不能超过4kb；web storage的存储大小5MB</li><li>作用：cookie是用于客户端和服务端间的信息传递；web storage是用于本地大容量存储数据；</li><li>有期时间：cookie可设置失效时间，localstorage除非主动删除；sessionstorage关闭会话窗口失效</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;br&gt;Cookie是保存在客户机的文本文件（IE保存在</summary>
      
    
    
    
    <category term="浏览器" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="Cookie" scheme="http://example.com/tags/Cookie/"/>
    
    <category term="localStorage" scheme="http://example.com/tags/localStorage/"/>
    
    <category term="sessionStorage" scheme="http://example.com/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>js-原型-原型链</title>
    <link href="http://example.com/2020/12/21/js-prototype/"/>
    <id>http://example.com/2020/12/21/js-prototype/</id>
    <published>2020-12-21T15:51:09.000Z</published>
    <updated>2021-11-27T09:16:40.969Z</updated>
    
    <content type="html"><![CDATA[<ul><li>构造函数</li><li>原型</li><li>原型链</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>通过 <font color='red'>new</font> 函数名来实例化对象的函数叫构造函数。任何的函数都可以作为构造函数存在。<br>之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要 功能为 初始化对象，特点是和new 一起使用。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">&#x27;孙悟空&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong><font color='red'>f1</font>就是一个构造函数</strong></p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<font color='red'>prototype</font>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。<br>对象具有属性<font color='red'><strong>proto</strong></font>，可称为隐式原型，一个对象的隐式原型指向<font color='red'>构造该对象的构造函数的原型</font>，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f1.__proto__ === Foo.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>方法（<font color='red'>Function</font>）方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（<font color='red'>prototype</font>），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做<font color='red'>constructor</font>，这个属性包含了一个指针，指回原构造函数。</strong></p><ul><li><strong>每个构造函数都有一个prototype原型对象</strong></li><li><strong>prototype原型对象里的constructor指向构造函数本身</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="prototype.jpg" alt="prototype"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们来分析一下上图</p><blockquote><p><strong>1.构造函数Foo()<br>构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。</strong><br><strong>2.原型对象Foo.prototype<br>Foo.prototype保存着实例共享的方法，有一个指针<font color='red'>constructor</font>指回构造函数。</strong><br><strong>3.实例<br><font color='red'>f1和f2</font>是Foo这个对象的两个实例，这两个对象也有属性<font color='red'><strong>proto</strong></font>，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</strong></p></blockquote><p><strong>另外：<br>构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？<br>指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。</strong></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</strong></p><p>举例说明: f1 → Foo → Object ，foo继承Foo，Foo继承Object</p><p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</strong><br><strong><font color='red'>Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有__proto__这个属性。</font></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>大部分参考作者doris的内容，具体可看作者doris<a href="https://www.zhihu.com/question/34183746/answer/58155878">知乎文章</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;原型&lt;/li&gt;
&lt;li&gt;原型链&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;通过 &lt;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="prototype" scheme="http://example.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>CSS 盒模型</title>
    <link href="http://example.com/2020/12/18/css-box/"/>
    <id>http://example.com/2020/12/18/css-box/</id>
    <published>2020-12-18T11:42:05.000Z</published>
    <updated>2021-11-27T09:18:30.754Z</updated>
    
    <content type="html"><![CDATA[<p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><ul><li>W3C标准盒模型</li><li>IE盒模型</li><li>两种盒模型的区别</li></ul><p>盒子模型<br><img src="box-model.png" alt="盒子模型"></p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong>- 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h2 id="W3C标准盒模型"><a href="#W3C标准盒模型" class="headerlink" title="W3C标准盒模型"></a>W3C标准盒模型</h2><p><img src="test2.jpg" alt="标准盒模型"><br><font color='red'><strong>盒子的内容区域(content) = 设置的width/height</strong></font><br><strong>标准盒模型的宽高</strong><br><font color='red'><strong>width=  content + padding * 2 + border * 2<br>height=  content + padding * 2 + border * 2</strong></font></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#87CEFA</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid<span class="number">#FFA07A</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="test.PNG" alt="标准盒模型"><br>我们点击f12，打开调试页面<br><img src="test1.PNG" alt="标准盒模型"><br>明明我们设置的是宽高为300x200的盒子，发现却是一个360x260的盒子。<br>盒子的宽高：<br><strong>360(width) = 300(content) + 20(padding) * 2 + 10(border) * 2</strong><br><strong>260(height) = 200(content) + 20(padding) * 2 + 10(border) * 2</strong></p><h2 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h2><p><img src="test3.jpg" alt="IE盒模型"><br><font color='red'><strong>盒子的宽高 = 设置的width/height</strong></font></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#FFA07A</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="number">#87CEFA</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    box-sizing: border-box; // 改变盒模型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="test5.PNG" alt="IE盒模型"><br>我们点击f12，打开调试页面<br><img src="test4.PNG" alt="IE盒模型"></p><p>盒子的宽高：<br><strong>300(width) = 240(content) + 20(padding) * 2 + 10(border) * 2</strong><br><strong>200(height) = 140(content) + 20(padding) * 2 + 10(border) * 2</strong></p><h2 id="两种盒模型的区别"><a href="#两种盒模型的区别" class="headerlink" title="两种盒模型的区别"></a>两种盒模型的区别</h2><ul><li>在 标准盒子模型中，width 和 height 指的是<strong>内容区域的宽度和高度</strong>。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li>IE盒子模型中，width 和 height 指的是<strong>内容区域</strong>+<strong>border</strong>+<strong>padding</strong>的宽度和高度。</li></ul><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>如果想要切换盒模型也很简单，这里需要借助css3的box-sizing属性</p><blockquote><ul><li><strong>box-sizing: content-box</strong> 是W3C盒模型</li><li><strong>box-sizing: border-box</strong> 是IE盒模型</li></ul></blockquote><p><strong>box-sizing的默认属性是content-box</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。&lt;br&gt;CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。&lt;br&gt;盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js的执行机制</title>
    <link href="http://example.com/2020/12/15/js-Event-Loop/"/>
    <id>http://example.com/2020/12/15/js-Event-Loop/</id>
    <published>2020-12-15T15:46:41.000Z</published>
    <updated>2021-11-27T09:17:15.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h1><h2 id="为什么js是单线程？"><a href="#为什么js是单线程？" class="headerlink" title="为什么js是单线程？"></a>为什么js是单线程？</h2><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h2 id="为什么要有事件循环？"><a href="#为什么要有事件循环？" class="headerlink" title="为什么要有事件循环？"></a>为什么要有事件循环？</h2><p>因为Javascript在浏览器中是单线程，所以在进行一个延时操作时并不能真的就让进程在原地等待那么久，那样用户的相关操作就“卡死”在哪里了，所以引入了事件循环的机制来，将需要消耗时间的操作“跳过去”，等主线程的操作完成了，再检查任务队列中是否还有任务，然后将任务调出来执行。就这样反复循环执行，所以就叫做事件循环。<br><img src="event.png" alt="Event Loop"><br>导图表达的内容：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;发送成功!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入<strong>Event Table</strong>，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入<strong>Event Queue</strong>。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p><h2 id="事件循环中的setTimeout"><a href="#事件循环中的setTimeout" class="headerlink" title="事件循环中的setTimeout"></a>事件循环中的setTimeout</h2><p>大家对他的第一印象就是<strong>异步</strong>可以延时执行，我们经常这么实现延时3秒执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;延时3秒&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？<br>先看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;执行console&#x27;</span>);</span><br></pre></td></tr></table></figure><p>根据前面我们的结论，setTimeout是<strong>异步</strong>的，应该先执行console.log这个同步任务，所以我们的结论是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行console</span></span><br><span class="line"><span class="comment">//task()</span></span><br></pre></td></tr></table></figure><p>去验证一下，结果正确！<br>然后我们修改一下前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">sleep(<span class="number">10000000</span>)</span><br></pre></td></tr></table></figure><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？<br>这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：</p><ul><li><font color='red'><strong>task()</strong></font>进入Event Table并注册,计时开始。</li><li>执行<font color='red'><strong>sleep</strong></font>函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件<font color='red'><strong>timeout</strong></font>完成，<font color='red'><strong>task()</strong></font>进入<strong>Event Queue</strong>，但是<font color='red'><strong>sleep</strong></font>也太慢了吧，还没执行完，只好等着。</li><li><font color='red'><strong>sleep</strong></font>终于执行完了，<font color='red'><strong>task()</strong></font>终于从<strong>Event Queue</strong>进入了主线程执行。</li></ul><p>上述的流程走完，我们知道<font color='red'><strong>setTimeout</strong></font>这个函数，是经过指定时间后，把要执行的任务(本例中为<font color='red'><strong>task()</strong></font>)加入到<strong>Event Queue</strong>中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><h3 id="setTimeout-fn-0-示例"><a href="#setTimeout-fn-0-示例" class="headerlink" title="setTimeout(fn,0)示例"></a>setTimeout(fn,0)示例</h3><p>我们还经常遇到 <strong>setTimeout(fn,0)</strong> 这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？<br>答案是不会的，<strong>setTimeout(fn,0)</strong> 的含义是：<strong>指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。</strong><br>举例说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>结果：a d c b</strong></p><ul><li> <strong>console.log(‘a’)</strong> 和 <strong>console.log(‘d’)</strong> 进入主线程</li><li> 定时器 <strong>setTimeout</strong> 延迟一段时间执行，顾名思义异步任务进入<strong>Event Queue</strong>中，等待主线程任务执行完毕，再进入主线程执行。</li></ul><p>有人疑惑为什么<strong>c</strong>比<strong>b</strong>先输出？<br><strong>定时器的延迟时间为 0 并不是立刻执行，只是代表相比于其他定时器更早的进入主线程中执行。即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</strong><br>如果宏任务里的settimeout延迟时间不一样，优先执行短的，等短的settimeout整个宏任务执行完了才到长的settimeout<br>因为<strong>c</strong>的延迟时间比<strong>b</strong>短，所以更早进入主线程。</p><h2 id="事件循环中的setInterval"><a href="#事件循环中的setInterval" class="headerlink" title="事件循环中的setInterval"></a>事件循环中的setInterval</h2><p><font color='red'><strong>setTimeout</strong></font> 的孪生兄弟 <font color='red'><strong>setInterval</strong></font>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<font color='red'><strong>setInterval</strong></font> 会每隔指定的时间将注册的函数置入<strong>Event Queue</strong>，如果前面的任务耗时太久，那么同样需要等待。<br>唯一需要注意的一点是，对于 <font color='red'><strong>setInterval(fn,ms)</strong></font> 来说，我们已经知道 <strong>不是</strong> 每过ms秒会执行一次fn，而是每过ms秒，会有fn进入 <strong>Event Queue</strong> 。<br><strong>一旦 <font color='red'>setInterval</font> 的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</strong></p><h2 id="事件循环中的Promise与process-nextTick-callback"><a href="#事件循环中的Promise与process-nextTick-callback" class="headerlink" title="事件循环中的Promise与process.nextTick(callback)"></a>事件循环中的Promise与process.nextTick(callback)</h2><p>除了广义的<strong>同步</strong>任务和<strong>异步</strong>任务，我们对任务有更精细的定义：</p><ul><li><font color='red'><strong>macro-task(宏任务)</strong></font>  ：包括<strong>整体代码script，setTimeout，setInterval</strong></li><li><font color='red'><strong>micro-task(微任务)</strong></font> ：<strong>Promise，process.nextTick</strong></li></ul><p>不同类型的任务会进入对应的<strong>Event Queue</strong>，比如<strong>setTimeout</strong>和<strong>setInterval</strong>会进入相同的<strong>Event Queue</strong>。</p><p><strong>事件循环的顺序，决定js代码的执行顺序。</strong>进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。<br>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;console&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<strong>setTimeout</strong>，那么将其回调函数注册后分发到宏任务<strong>Event Queue</strong>。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<strong>Promise</strong>，<strong>new Promise</strong>立即执行，<strong>then</strong>函数分发到微任务<strong>Event Queue</strong>。</li><li>遇到console.log()，立即执行。</li><li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 <strong>then</strong> 在微任务 <strong>Event Queue</strong> 里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 <strong>Event Queue</strong> 开始。我们发现了宏任务 <strong>Event Queue</strong> 中 <strong>setTimeout</strong> 对应的回调函数，立即执行。</li><li>结束。</li></ul><p>事件循环，宏任务，微任务的关系如图所示：<br><img src="mask.png" alt="mask"></p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>分析一段复杂代码验收成果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第一轮事件循环流程分析如下："><a href="#第一轮事件循环流程分析如下：" class="headerlink" title="第一轮事件循环流程分析如下："></a>第一轮事件循环流程分析如下：</h3><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到 <font color='red'><strong>setTimeout</strong></font> ，其回调函数被分发到宏任务<strong>Event Queue</strong>中。我们暂且记为<font color='red'><strong>setTimeout1</strong></font> 。</li><li>遇到 <font color='red'><strong>process.nextTick()</strong></font> ，其回调函数被分发到微任务<strong>Event Queue</strong>中。我们记为<font color='red'><strong>process1</strong></font> 。</li><li>遇到 <font color='red'><strong>Promise</strong></font>，<font color='red'><strong>new Promise</strong></font>直接执行，输出7。<font color='red'><strong>then1</strong></font>被分发到微任务<strong>Event Queue</strong>中。我们记为<font color='red'><strong>then1</strong></font> 。</li><li>又遇到了 <font color='red'><strong>setTimeout</strong></font> ，其回调函数被分发到宏任务Event Queue中，我们记为<font color='red'><strong>setTimeout2</strong></font> 。</li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout1</td><td align="center">process1</td></tr><tr><td align="center">setTimeout2</td><td align="center">then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各<strong>Event Queue</strong>的情况，此时已经输出了1和7。</li><li>我们发现了 <font color='red'><strong>process1</strong></font> 和 <font color='red'><strong>then1</strong></font> 两个微任务。</li><li>执行 <font color='red'><strong>process1</strong></font>,输出6。</li><li>执行 <font color='red'><strong>then1</strong></font>，输出8。<br>第一轮事件循环正式结束，结果是输出<strong>1，7，6，8</strong>。</li></ul><h3 id="第二轮事件循环流程分析如下："><a href="#第二轮事件循环流程分析如下：" class="headerlink" title="第二轮事件循环流程分析如下："></a>第二轮事件循环流程分析如下：</h3><p><strong>循环从setTimeout1宏任务开始</strong></p><ul><li>首先输出2。接下来遇到了 <font color='red'><strong>process.nextTick()</strong></font> ，同样将其分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>process2</strong></font> 。<font color='red'><strong>new Promise</strong></font> 立即执行输出4，then也分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>then2</strong></font> 。</li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout2</td><td align="center">process2</td></tr><tr><td align="center"></td><td align="center">then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有<font color='red'><strong>process2</strong></font>和<font color='red'><strong>then2</strong></font>两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，<br>第二轮输出<strong>2，4，3，5</strong>。</li></ul><h3 id="第三轮事件循环流程分析如下："><a href="#第三轮事件循环流程分析如下：" class="headerlink" title="第三轮事件循环流程分析如下："></a>第三轮事件循环流程分析如下：</h3><ul><li><p>此时只剩<font color='red'><strong>setTimeout2</strong></font>了，执行。</p></li><li><p>直接输出9。</p></li><li><p>将 <font color='red'><strong>process.nextTick()</strong></font>分发到微任务<strong>Event Queue</strong>中。记为<font color='red'><strong>process3</strong></font>。</p></li><li><p>直接执行 <font color='red'><strong>new Promise</strong></font>，输出11。</p></li><li><p>将then分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>then3</strong></font>。</p><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center"></td><td align="center">process3</td></tr><tr><td align="center"></td><td align="center">then3</td></tr></tbody></table></li><li><p>第三轮事件循环宏任务执行结束，执行两个微任务<font color='red'><strong>process3</strong></font>和<font color='red'><strong>then3</strong></font>。</p></li><li><p>输出10。</p></li><li><p>输出12。</p></li><li><p>第三轮事件循环结束，</p></li></ul><p>第三轮输出<strong>9，11，10，12</strong>。</p><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><p><strong>大部分转载作者-ssssyoki的内容，具体可看作者-ssssyoki<a href="https://juejin.cn/post/6844903512845860872#heading-4">掘金推文</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS事件循环&quot;&gt;&lt;a href=&quot;#JS事件循环&quot; class=&quot;headerlink&quot; title=&quot;JS事件循环&quot;&gt;&lt;/a&gt;JS事件循环&lt;/h1&gt;&lt;h2 id=&quot;为什么js是单线程？&quot;&gt;&lt;a href=&quot;#为什么js是单线程？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS new操作符</title>
    <link href="http://example.com/2020/08/28/js-new/"/>
    <id>http://example.com/2020/08/28/js-new/</id>
    <published>2020-08-27T19:31:25.000Z</published>
    <updated>2021-11-27T09:15:09.560Z</updated>
    
    <content type="html"><![CDATA[<p><strong>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</strong></p><ul><li>new操作符做了什么？</li><li>模拟实现JS的new操作符</li></ul><h2 id="new操作符做了什么？"><a href="#new操作符做了什么？" class="headerlink" title="new操作符做了什么？"></a>new操作符做了什么？</h2><p><strong>new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象</strong></p><ol><li>创建一个空的对象</li><li>将空对象的原型prototype指向构造函数的原型</li><li>将空对象作为构造函数的上下文（改变this指向）</li><li>确保返回的是对象</li></ol><h3 id="构造函数返回值的判断-对第4步的解析"><a href="#构造函数返回值的判断-对第4步的解析" class="headerlink" title="构造函数返回值的判断(对第4步的解析)"></a>构造函数返回值的判断(对第4步的解析)</h3><blockquote><p>一般情况下构造函数没有返回值，但是作为函数，是可以有返回值的。<br>那么在构造函数有返回值的情况下，new操作符做了什么？</p></blockquote><p>先看两个例子：<br>注意一下两个返回值的差异</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return undefined/NaN/&#x27;string&#x27;/null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;快乐每一天&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// &#123; name:&#x27;快乐每一天&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>:<span class="number">12</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;快乐每一天&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// &#123; age:12 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>在new的时候，会对构造函数的返回值做一些判断：</p><blockquote><ol><li>如果返回值是基础数据类型，则忽略返回值；</li><li>如果返回值是引用数据类型，则使用return 的返回，也就是new操作符无效；</li></ol></blockquote><h2 id="模拟实现JS的new操作符"><a href="#模拟实现JS的new操作符" class="headerlink" title="模拟实现JS的new操作符"></a>模拟实现JS的new操作符</h2><h3 id="proto和prototype区别"><a href="#proto和prototype区别" class="headerlink" title="proto和prototype区别"></a>proto和prototype区别</h3><blockquote><p><strong>方法</strong>（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性proto，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。<br><strong>方法</strong>这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</p></blockquote><p><img src="proto.jpg" alt="proto"></p><h3 id="分析图片"><a href="#分析图片" class="headerlink" title="分析图片"></a>分析图片</h3><blockquote><p><strong>1. 构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。<br>2. 原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。<br>3. 实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</strong></p></blockquote><p>另外：构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。<br><strong>原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。</strong><br>实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，<strong>指向构造函数的原型对象</strong>，这样子就可以像上面1所说的访问原型对象的所有方法啦。<br>另外：<strong>构造函数</strong>Foo()除了是方法，也是对象啊，它也有proto属性，指向谁呢？<br><strong>指向它的构造函数的原型对象</strong>。函数的构造函数不就是Function嘛，因此这里的proto指向了Function.prototype。<br>其实除了Foo()，Function(), Object()也是一样的道理。<br><strong>原型对象</strong>也是对象啊，它的proto属性，又指向谁呢？<br>同理，<strong>指向它的构造函数的原型对象</strong>。这里是Object.prototype.最后，Object.prototype的proto属性指向null。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p><strong>对象有属性proto,指向该对象的构造函数的原型对象。<br>方法除了有属性proto,还有属性prototype，prototype指向该方法的原型对象。</strong></p></blockquote><h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 先创建一个空的新对象<br>2. 因为 obj 对象需要访问到构造函数原型链上的属性，所以空对象的proto需要指向后遭函数的prototype<br>3. 将obj绑定到构造函数中，并传入其余参数（改变this指向）<br>4. 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值</strong><br>接下来我们来使用下该函数，看看是否和 new 操作符一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = create(Test, <span class="string">&#x27;yck&#x27;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// &#x27;yck&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age) <span class="comment">// 26</span></span><br><span class="line">a.sayName() <span class="comment">// &#x27;yck&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new操作符做了什么？&lt;/li&gt;
&lt;li&gt;模拟实现JS的new操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;new操作符做了什么？&quot;&gt;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="new" scheme="http://example.com/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>JS事件的三个阶段</title>
    <link href="http://example.com/2020/08/25/js-event/"/>
    <id>http://example.com/2020/08/25/js-event/</id>
    <published>2020-08-24T19:18:19.000Z</published>
    <updated>2021-11-27T09:17:20.762Z</updated>
    
    <content type="html"><![CDATA[<p><strong>事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段。<br>事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这个路径回溯到文档跟节点。</strong><br><img src="event.png" alt="事件"></p><ul><li>捕获阶段</li><li>目标阶段</li><li>冒泡阶段</li><li>事件代理</li></ul><h2 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h2><p><strong>当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。</strong></p><p><img src="event3.png" alt="事件捕获"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#ancestors</span>&#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: red;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#father</span>&#123;</span></span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background: blue;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#son</span>&#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: green;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ancestors&quot;</span>&gt;</span>祖先</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span>父亲</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span>儿子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ancestors&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;祖先&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;父亲&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;son&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;儿子&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="event.jpg" alt="事件捕获"><br><img src="event1.jpg" alt="事件捕获"><br><strong>当我点击儿子的时候，就会从最外层开始触发，因为没有对document/html/body进行监听，所以从祖先开始触发，直到目标节点</strong></p><h2 id="目标阶段"><a href="#目标阶段" class="headerlink" title="目标阶段"></a>目标阶段</h2><p><strong>当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发，然后会逆向回流，直到传播至最外层的文档节点。</strong></p><h2 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h2><p><strong>事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点（文档）。所有现代浏览器都支持事件冒泡，并且会将事件一直冒泡到window对象</strong><br><img src="event2.png" alt="事件冒泡"></p><p>示例（html代码同上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ancestors&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;祖先&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;父亲&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;son&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;儿子&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="event2.jpg" alt="事件冒泡"><br><strong>当点击儿子的时候，事件在儿子元素上触发后，开始逐级向上冒泡。</strong></p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><blockquote><p>事件代理就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。<br>举个例子：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。<br>这里其实还有2层意思的：<br>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p></blockquote><h3 id="为什么要用事件代理"><a href="#为什么要用事件代理" class="headerlink" title="为什么要用事件代理"></a>为什么要用事件代理</h3><p><strong>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件代理，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</strong></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>比如现在我们需要对一个100行10列表格里的每一个td进行事件监听，当点击某个表格的时候则变为可编辑状态。如果把事件处理器加到这1000个单元格会产生一个很大的性能问题，并且有可能导致内存泄露甚至是浏览器的崩溃。相反地，使用事件代理，你只需要把一个事件处理器添加到table元素上就可以了，这个函数可以把点击事件给截下来，并且判断出是哪个单元格被点击了。<br><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>6<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>7<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>8<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>9<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;table&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">table.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.eventPhase) <span class="comment">// 判断当前的事件阶段（1：捕获，2：目标，3：冒泡）</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.nodeName.toLowerCase() === <span class="string">&#x27;td&#x27;</span>)&#123; <span class="comment">// 只有点击的是td才会触发</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.target)</span><br><span class="line">  <span class="built_in">console</span>.log(event.currentTarget) <span class="comment">// 监听器触发事件的元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="event3.jpg" alt="事件代理"><br><img src="event4.jpg" alt="事件代理"><br>当我点击5的时候，td就会通过事件冒泡到绑定的触发器table元素，然后获取到你点击的元素。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>通过刚才的对比介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点： 1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。 2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。 3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段。&lt;br&gt;事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动</title>
    <link href="http://example.com/2020/08/22/css-clear-float/"/>
    <id>http://example.com/2020/08/22/css-clear-float/</id>
    <published>2020-08-21T19:09:35.000Z</published>
    <updated>2021-11-27T09:18:26.048Z</updated>
    
    <content type="html"><![CDATA[<p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫<strong>浮动溢出</strong>，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br><strong>清除浮动的本质：主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题。</strong></p><ul><li>示例</li><li>方法</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    background-color: darksalmon;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line">    background-color: aquamarine;</span><br><span class="line">    float: right;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="float.jpg" alt="float"><br><strong>容器没有包含浮动元素</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="使用带clear属性的块级元素-不推荐"><a href="#使用带clear属性的块级元素-不推荐" class="headerlink" title="使用带clear属性的块级元素(不推荐)"></a>使用带clear属性的块级元素(不推荐)</h3><blockquote><p><strong>在浮动元素后面添加一个带clear属性的块级元素<br>优点：简单，代码少，浏览器支持好<br>缺点：如果页面浮动布局多，则需要很多空标签</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.clear</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 添加 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="clear.jpg" alt="清除浮动"></p><h3 id="使用CSS的overflow属性-不推荐"><a href="#使用CSS的overflow属性-不推荐" class="headerlink" title="使用CSS的overflow属性(不推荐)"></a>使用CSS的overflow属性(不推荐)</h3><blockquote><p><strong>给浮动元素的容器添加overflow属性<br>优点：不存在结构和语义化问题，代码量极少 　　<br>缺点：多个嵌套后，firefox某些情况会造成内容全选；</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line"><span class="css">    <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>; <span class="comment">/*添加,或者overflow:auto;*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用CSS的-after伪元素-推荐使用"><a href="#使用CSS的-after伪元素-推荐使用" class="headerlink" title="使用CSS的:after伪元素(推荐使用)"></a>使用CSS的:after伪元素(推荐使用)</h3><blockquote><p><strong>给浮动元素的容器添加一个class，然后给这个class添加一个:after伪元素实现元素末尾添加一个隐藏的块级元素清理浮动。<br>优点：兼容性好<br>缺点：ie6-7不支持伪元素：after</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123; <span class="comment">/*添加*/</span></span></span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: block;</span><br><span class="line">      height: 0;</span><br><span class="line">      clear: both;</span><br><span class="line">      visibility: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用before和after双伪元素清除浮动-推荐使用"><a href="#使用before和after双伪元素清除浮动-推荐使用" class="headerlink" title="使用before和after双伪元素清除浮动(推荐使用)"></a>使用before和after双伪元素清除浮动(推荐使用)</h3><p>**给浮动元素的容器添加一个class，然后给这个class添加一个:after伪元素实现元素末尾添加一个隐藏的块级元素清理浮动。<br>**</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after.clearfix</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: table;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line">      clear: both;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="容器浮动-不推荐"><a href="#容器浮动-不推荐" class="headerlink" title="容器浮动(不推荐)"></a>容器浮动(不推荐)</h3><p>**让浮动元素的容器也浮动起来<br>优点：代码少<br>缺点：会导致整个页面大部分都处于浮动状态，容易出现问题 **</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="container.jpg" alt="清除浮动"><br><strong>因为没给容器设置宽度</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫&lt;strong&gt;浮动溢出&lt;/st</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
    <category term="float" scheme="http://example.com/tags/float/"/>
    
  </entry>
  
  <entry>
    <title>压缩算法</title>
    <link href="http://example.com/2020/08/21/js-compress/"/>
    <id>http://example.com/2020/08/21/js-compress/</id>
    <published>2020-08-20T19:05:28.000Z</published>
    <updated>2021-11-27T09:17:37.775Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目描述</li><li>思路</li><li>代码</li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为m|S，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入第一行包含一个字符串s，代表压缩后的字符串。<br>S的长度&lt;=1000;<br>S仅包含大写字母、[、]、|;<br>解压后的字符串长度不超过100000;<br>压缩递归层数不超过10层;</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p><strong>输出一个字符串，代表解压后的字符串。</strong></p></blockquote><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p><strong>HG[3|B[2|CA]]F</strong></p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p><strong>HGBCACABCACABCACAF<br>HG[3|B[2|CA]]F−&gt;HG[3|BCACA]F−&gt;HGBCACABCACABCACAF</strong></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过<strong>递归</strong>的方法实现，每次寻找最内层的[n|xx]通过截取n和xx字符串，将[n|xx]解压并替换，再将当前的字符串递归，直至字符串没有[n|xx]，输出字符串。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\[\d+\|[A-Z]*\]/</span> <span class="comment">// 匹配最内层的[n|xxx]的正则表达式</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/\|/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str1 = reg.exec(str)</span><br><span class="line">  <span class="keyword">if</span> (!str1)&#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> substr = str1[<span class="number">0</span>] <span class="comment">// 最内层的[n|xxx]</span></span><br><span class="line">  <span class="keyword">const</span> index = str1.index <span class="comment">// 最内层的[n|xxx]索引</span></span><br><span class="line">  <span class="keyword">const</span> mindex = reg2.exec(substr).index <span class="comment">// 代表&#x27;|&#x27;符号的index</span></span><br><span class="line">  <span class="keyword">const</span> num = <span class="built_in">Number</span>(substr.slice(<span class="number">1</span>,mindex)) <span class="comment">//n</span></span><br><span class="line">  <span class="keyword">const</span> sonstr = substr.slice(mindex+<span class="number">1</span>,-<span class="number">1</span>) <span class="comment">// xxx</span></span><br><span class="line">  <span class="keyword">const</span> str2 = str.replace(reg,sonstr.repeat(num))</span><br><span class="line">  compress(str2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;题目描述&lt;/li&gt;
&lt;li&gt;思路&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;小Q想要给他的朋友发送一个</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
