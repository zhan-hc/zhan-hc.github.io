<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笨鸟</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-19T16:27:50.750Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HC-ZHAN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树组件实现虚拟滚动</title>
    <link href="http://example.com/2021/07/20/tree-inventScroll/"/>
    <id>http://example.com/2021/07/20/tree-inventScroll/</id>
    <published>2021-07-19T16:15:01.000Z</published>
    <updated>2021-07-19T16:27:50.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>当数据过多时，渲染出现卡顿。因为 dom 数量过大。</li></ol><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ul><li><ol><li>将树形数据和 dom 扁平化</li></ol></li><li><ol start="2"><li>虚拟长列表控制 dom 渲染数量</li></ol></li></ul><h4 id="1-扁平化"><a href="#1-扁平化" class="headerlink" title="1.扁平化"></a>1.扁平化</h4><p><img src="tree1.png" alt="扁平化tree的DOM结构图"></p><center>扁平化tree的DOM结构图-1</center>由上图可以看出经过扁平化处理后的父子节点dom是同级的，接下来我们来实现将tree数据扁平化处理。    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">&quot;课程1&quot;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-1&quot;</span> &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">5</span>,</span><br><span class="line">        title: <span class="string">&quot;课程1-2&quot;</span>,</span><br><span class="line">       children: [</span><br><span class="line">          &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-1&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-2&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&quot;课程2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&quot;课程3&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> flatData = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&quot;课程1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">title</span>: <span class="string">&quot;课程1-2-2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&quot;课程2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&quot;课程3&quot;</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将 treeData 的数据格式转变成 faltData,将数据<strong>扁平化</strong>的过程<br><strong>实现思路</strong><br>有<strong>递归</strong>和<strong>迭代</strong>，我们先来讲讲两者的异同。</p><ul><li>递归使用的是选择结构，能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。</li><li>迭代使用的是循环结构，不需要反复调用函数和占用额外的内存。因此我们应该视不同 情况选择不同的代码实现方式。<br>在算法中我们会遇到很多递归实现的案例，所有的递归都可以转换成非递归实现，其中转换的本质是：<strong>递归是解析器(引擎)来帮我们做了栈的存取，非递归是手动创建栈来模拟栈的存取过程</strong>。<br>下面我们通过<strong>栈</strong>来实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">faltten</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flatData = []</span><br><span class="line">  <span class="keyword">let</span> stack = [...tree]</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack.shift()</span><br><span class="line">    <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">      stack.unshift(...node.children)</span><br><span class="line">    &#125;</span><br><span class="line">    flatData.push(&#123; <span class="attr">id</span>: node.id, <span class="attr">title</span>: node.title &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flatData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们通过<strong>递归</strong>来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">faltten</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flatData = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    formatData.push(&#123;</span><br><span class="line">      id: data[i].id,</span><br><span class="line">      title: data[i].title,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (data[i].children) &#123;</span><br><span class="line">      formatData = formatData.concat(faltten(data[i].children))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> formatData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现扁平化的树型组件功能，我们的数据字段需要 expand，visible，children，level 字段。大致结构：<br>{<br>&emsp;&emsp;key:<br>&emsp;&emsp;title:<br>&emsp;&emsp;level: 通过 level 标识节点层级，通过 css 实现层级的区别<br>&emsp;&emsp;visible: 节点的显示隐藏属性<br>&emsp;&emsp;expand: 展开状态<br>&emsp;&emsp;children: 存储子节点的引用，通过引用控制子节点的显示隐藏<br>}</p><p>通过上面的分析，我们来继续实现新增字段之后的扁平化处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flatten (data, arr = [], parent = <span class="literal">null</span>, level = <span class="number">0</span>, visible = <span class="literal">true</span>, children = [], insert = <span class="literal">null</span>) &#123;</span><br><span class="line">      arr.push(&#123;...data, level, parent, visible, children&#125;)</span><br><span class="line">      <span class="keyword">if</span> (insert !== <span class="literal">null</span>) &#123;</span><br><span class="line">        arr[insert].children.push(arr[arr.length - <span class="number">1</span>]) <span class="comment">// 给父节点的children字段添加子节点引用</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (data.children) &#123;</span><br><span class="line">        insert = arr.length - <span class="number">1</span> <span class="comment">// 父节点插入子节点引用索引</span></span><br><span class="line">        data.children.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.flatten(item, arr, arr[arr.length - <span class="number">1</span>], level + <span class="number">1</span>, data.expand, [], insert)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>难点在于存储子节点的 data 引用，存储子节点的引用是因为子节点对象和 children 对象指向的是同一个内存地址，所以后续隐藏节点的时候，我们可以直接通过获取当前点击节点的 children 字段，进行 visible 属性的隐藏设置。</p><p><strong>扁平化数据的树型渲染</strong></p><p>树型节点的遍历</p><p><img src="tree2.png" alt="扁平化tree的html代码图"></p><center>扁平化tree的html代码图-2</center>节点的层级区别通过**level**属性来控制**unHiddenList**代表visible属性为false (即未展开) 的数据列表<p><strong>节点的展开和隐藏实现</strong></p><p><img src="tree3.png" alt="展开隐藏函数代码图"></p><center>展开隐藏函数代码图-3</center><h4 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h4><p><strong>html</strong><br>为了方便直接看清 dom 结构，隐藏了树型 dom</p><p><img src="tree4.png" alt="虚拟滚动html代码图"></p><center>虚拟滚动html代码图-4</center>**contentHeight**代表整个滚动的内容高度**contentHeight = unHiddenList.length * itemHeight(节点高度)**以下是滚动时触发函数![虚拟滚动函数代码图](tree5.png)<center>虚拟滚动函数代码图-5</center>其中的20代表的是可视item，25代表的是item的高度，数字可以根据需求自己设置。其中使用`transform`来实现虚拟滚动的原因是由于 `transform` 是位于 `Composite Layers` 层，而 `width` 、 `left` 、 `margin` 等则是位于 `Layout` 层，在 `Layout` 层发生的改变必定导致 `Paint Setup and Paint`  ->  `Composite Layers` ，所以相对而言使用 `transform` 实现的动画效果肯定比 `left` 这些更加流畅。<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="invent.gif" alt="invent.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;当数据过多时，渲染出现卡顿。因为 dom 数量过大。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;实现方案&quot;&gt;&lt;a href=&quot;#实现</summary>
      
    
    
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>http1.0/1.1/2.0区别</title>
    <link href="http://example.com/2021/03/23/http/"/>
    <id>http://example.com/2021/03/23/http/</id>
    <published>2021-03-23T15:40:51.000Z</published>
    <updated>2021-03-23T16:34:54.091Z</updated>
    
    <content type="html"><![CDATA[<ul><li>http1.0与http1.1区别</li><li>http2.0的特点</li><li>http1.1与http2.0区别</li><li>混淆的问题</li></ul><h2 id="http1-0与http1-1区别"><a href="#http1-0与http1-1区别" class="headerlink" title="http1.0与http1.1区别"></a>http1.0与http1.1区别</h2><ul><li><strong>长连接(Persistent Connection)</strong><blockquote><p>HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。<br><strong>HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为<font color="red">Keep-Alive</font>时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。</strong></p></blockquote></li><li><strong>节约带宽</strong><blockquote><p>HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p></blockquote></li><li><strong>HOST域</strong><blockquote><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</p></blockquote></li><li><strong>请求方法</strong><blockquote><p>HTTP1.1增加了<strong>OPTIONS</strong>，<strong>PUT</strong>，<strong>DELETE</strong>，<strong>TRACE</strong>，<strong>CONNECT</strong>的请求方法。</p></blockquote></li><li><strong>缓存处理</strong><blockquote><p>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如<strong>Entity tag，If-Unmodified-Since, If-Match, If-None-Match</strong>等更多可供选择的缓存头来控制缓存策略。</p></blockquote></li><li><strong>状态码</strong><blockquote><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></blockquote></li></ul><h2 id="http2-0的特点"><a href="#http2-0的特点" class="headerlink" title="http2.0的特点"></a>http2.0的特点</h2><ul><li><p><strong>二进制分帧层</strong><br>HTTP 2.0性能增强的核心，全在于新增的<strong>二进制分帧层</strong>，它定义了如何封装HTTP消息并在客户端与服务器之间传输。<br><img src="http4.jpg" alt="http"></p></li><li><p><strong>流、消息和帧</strong></p><ul><li><strong>流</strong>：已建立的连接的双向字节流</li><li><strong>消息</strong>：与逻辑消息对应的完整的一系列数据帧</li><li><strong>帧</strong>：HTTP2.0通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流</li></ul><p>所有HTTP 2.0通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。<br>每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。<br><img src="http5.jpg" alt="http"><br>简言之，HTTP 2.0把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。<br>相应地，很多流可以并行地在同一个TCP连接上交换消息。</p></li><li><p><strong>多向请求与响应</strong><br>在HTTP 1.x中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个TCP连接。<br>HTTP 2.0中的二进制分帧层突破了限制：客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。<br><img src="http6.jpg" alt="http"></p></li><li><p><strong>请求优先级</strong><br>每个HTTP2.0流里面有个优先值，这个优先值确定着客户端和服务器处理不同的流采取不同的优先级策略，高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。</p><h2 id="http1-1与http2-0区别"><a href="#http1-1与http2-0区别" class="headerlink" title="http1.1与http2.0区别"></a>http1.1与http2.0区别</h2></li><li><p><strong>多路复用</strong></p><blockquote><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p></blockquote></li></ul><p><img src="http2.jpg" alt="http"></p><ul><li><p><strong>头部数据压缩（<a href="https://imququ.com/post/header-compression-in-http2.html">深入了解头部压缩</a>）</strong></p><blockquote><p>在HTTP1.1中，HTTP请求和响应都是由<strong>状态行、请求/响应头部、消息主体</strong>三部分组成。一般而言，消息主体都会经过<strong>gzip压缩</strong>，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。<br>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。<br><img src="http.webp" alt="http"><br>HTTP 2.0连接的两端都知道已经发送了哪些首部，这些首部的值是什么，从而可以针对之前的数据只编码发送<strong>差异</strong>数据。头部数据通过字典存储(键值对)的形式进行存储<br><img src="http3.jpg" alt="http"></p></blockquote></li><li><p><strong>服务器推送</strong></p><blockquote><p>服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。<br>为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p></blockquote></li><li><p>普通的客户端请求过程：<br><img src="http_push.webp" alt="http"></p></li><li><p>服务端推送的过程：<br><img src="http_push1.webp" alt="http"></p></li></ul><h2 id="混淆的问题"><a href="#混淆的问题" class="headerlink" title="混淆的问题"></a>混淆的问题</h2><p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p><p>HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；<br>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；<br>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;http1.0与http1.1区别&lt;/li&gt;
&lt;li&gt;http2.0的特点&lt;/li&gt;
&lt;li&gt;http1.1与http2.0区别&lt;/li&gt;
&lt;li&gt;混淆的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;http1-0与http1-1区别&quot;&gt;&lt;a href=&quot;#htt</summary>
      
    
    
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>JS定时器不准确及解决方案</title>
    <link href="http://example.com/2021/02/09/js-setInterval/"/>
    <id>http://example.com/2021/02/09/js-setInterval/</id>
    <published>2021-02-09T07:12:45.000Z</published>
    <updated>2021-02-09T07:40:41.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><ul><li>浏览器中的所有JavaScript都在单线程上执行，所以异步事件（比如定时器）仅在线程空闲时才会被调度运行。</li><li>为了控制要执行的代码， JavaScript 配置了一个任务队列，这些异步事件任务会按照将它们添加到队列的顺序执行。</li><li>而setTimeout() 的第二个参数（延时时间）只是告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</li></ul><p><strong>因此定时器延迟是不能保证的。</strong></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="动态计算时差-（仅针对循环定时，只起修正作用-）"><a href="#动态计算时差-（仅针对循环定时，只起修正作用-）" class="headerlink" title="动态计算时差 （仅针对循环定时，只起修正作用 ）"></a>动态计算时差 （仅针对循环定时，只起修正作用 ）</h2><ul><li>在定时器开始前和运行时动态获取当前时间，在设置下一次定时时长时，在期望值基础上减去当前时延，以获得相对精准的定时运行效果。</li><li>此方法仅能消除setInterval()长时间运行造成的误差累计，但无法消除单个定时器执行延迟问题。</li></ul><p>注： 时差过大时，由于无法时间回流，只能按没有间隔处理，减轻影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//耗时任务</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">100000000</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">var</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">var</span> nextTime = <span class="number">1000</span> - offset;</span><br><span class="line">    <span class="keyword">if</span> (nextTime &lt; <span class="number">0</span>) nextTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(handle, nextTime);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">&#x27; --- &#x27;</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(handle, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用-Web-Worker"><a href="#使用-Web-Worker" class="headerlink" title="使用 Web Worker"></a>使用 Web Worker</h2><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//耗时任务</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">100000000</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker 解决方案</span></span><br><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">&#x27; --- &#x27;</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>)));</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;浏览器中的所有JavaScript都在单线程上执行，所以异步事件（比如定时器）仅在线程空闲时才会被调度运行。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>16进制颜色转换RGB原理</title>
    <link href="http://example.com/2020/12/28/js-rgba/"/>
    <id>http://example.com/2020/12/28/js-rgba/</id>
    <published>2020-12-28T03:59:48.000Z</published>
    <updated>2020-12-28T04:38:23.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RGB-三通道颜色"><a href="#RGB-三通道颜色" class="headerlink" title="RGB: 三通道颜色"></a>RGB: 三通道颜色</h2><ul><li>他是目前运用最广泛的颜色系统之一</li><li>可以通过红绿蓝三色通道, 外加alpha透明度, 来展示几乎所有的颜色</li><li>RGB是从颜色的发光原理来设定的, 相当于红绿蓝三个颜色通过不同亮度, 来组合成为需要的颜色</li><li>0为最暗, 255为最亮</li></ul><h2 id="RGB转换为HEX-16进制"><a href="#RGB转换为HEX-16进制" class="headerlink" title="RGB转换为HEX(16进制)"></a>RGB转换为HEX(16进制)</h2><p>RGB与HEX中每个颜色都是一一对应的关系<br><strong>RGB的数值 = 16 * HEX的第一位 + HEX的第二位</strong><br>示例如下:</p><ul><li>RGB: 92, 184, 232</li><li>92 / 16 = 5余12 -&gt; 5C</li><li>184 / 16 = 11余8 -&gt; B8</li><li>232 / 16 = 14余8 -&gt; E8</li><li>HEX = 5CB8E8</li></ul><h2 id="HEX转换RGB"><a href="#HEX转换RGB" class="headerlink" title="HEX转换RGB"></a>HEX转换RGB</h2><p>此转换就是将上述的转换逆转即可<br>示例如下</p><ul><li>HEX: F26BC1</li><li>F2 = 15和2 -&gt; 15 * 16 + 2 = 242</li><li>6B = 6和11 -&gt; 6 * 16 + 11 = 107</li><li>C1 = 12和1 -&gt; 12 * 16 + 1 = 193</li></ul><h2 id="常见算法题"><a href="#常见算法题" class="headerlink" title="常见算法题"></a>常见算法题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>设计一个函数，给出一个rgba数值，返回16进制的表达式及透明度。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p><strong>rgba(255,255,255,0.4)</strong></p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p><strong>颜色：#FFFFFF，透明度：0.4</strong></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = str.slice(<span class="number">5</span>,-<span class="number">1</span>).split(<span class="string">&#x27;,&#x27;</span>) <span class="comment">// 截取字符串</span></span><br><span class="line">    <span class="keyword">var</span> color = [<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">&#x27;颜色：#&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="built_in">Math</span>.floor((r[i]) / <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">let</span> y = <span class="built_in">Number</span>(r[i]) % <span class="number">16</span></span><br><span class="line">        res += color[c]</span><br><span class="line">        <span class="keyword">if</span>(y === <span class="number">0</span>) res += color[c]</span><br><span class="line">        <span class="keyword">else</span> res += color[y]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;res&#125;</span>，透明度：<span class="subst">$&#123;r[<span class="number">3</span>]&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RGB-三通道颜色&quot;&gt;&lt;a href=&quot;#RGB-三通道颜色&quot; class=&quot;headerlink&quot; title=&quot;RGB: 三通道颜色&quot;&gt;&lt;/a&gt;RGB: 三通道颜色&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;他是目前运用最广泛的颜色系统之一&lt;/li&gt;
&lt;li&gt;可以通过红绿蓝三</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="rgba" scheme="http://example.com/tags/rgba/"/>
    
  </entry>
  
  <entry>
    <title>变量提升和函数提升</title>
    <link href="http://example.com/2020/12/25/js-Hoisting/"/>
    <id>http://example.com/2020/12/25/js-Hoisting/</id>
    <published>2020-12-24T16:43:43.000Z</published>
    <updated>2020-12-24T18:32:51.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。<br>js怎么创建变量？<br><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>js在解析上面的代码的时候，其实会按照下面的方式进行解析的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>所以 js 并不是在我们定义一个变量的时候，声明完成之后立即赋值，而是把所有用到的变量全部声明之后，再到变量的定义的地方进行赋值，变量的声明的过程就是变量的提升。</p><p>现在我们来看看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>思考一下会输出什么？<br><strong>分析</strong><br>实际上的解析过程是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">var</span> b;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>变量在声明提升的时候，是全部提升到作用域的最前面，一个接着一个的。但是在变量赋值的时候就不是一个接着一个赋值了，而是<strong>赋值的位置</strong>在变量<strong>原本定义的位置</strong>。原本js定义变量的地方，在js运行到这里的时候，才会进行赋值操作，而没有运行到的变量，不会进行赋值操作。</p><p>所以变量的提升，<strong>提升的其实是变量的声明，而不是变量的赋值。</strong></p><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数的提升和变量的提升类似，都是提升到作用域的最开始的位置，只不过变量的提升是分两步的，第一步是变量声明的提升，第二步是变量的赋值。而函数的提升是直接将整个函数整体提升到作用域的最开始位置，相当于剪切过去的样子。</p><h3 id="同名方法"><a href="#同名方法" class="headerlink" title="同名方法"></a>同名方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>解析过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo2</span></span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p><strong>在js里同时有两个同名函数方法时，会默认调用最后一个同名方法</strong></p><h3 id="同名的函数表达式"><a href="#同名的函数表达式" class="headerlink" title="同名的函数表达式"></a>同名的函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>解析过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo1</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p><strong>实质是变量提升的过程</strong></p><h3 id="变量提升和函数提升的顺序"><a href="#变量提升和函数提升的顺序" class="headerlink" title="变量提升和函数提升的顺序"></a>变量提升和函数提升的顺序</h3><p>在作用域中，不管是变量还是函数，都会提升到作用域最开始的位置<br><strong>函数提升优先级高于变量提升，且不会被变量声明覆盖，但会被变量赋值覆盖（重点）</strong><br>举个例子：<br>下面的代码输出什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码在js眼中是这样解析的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a()</span></span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>所以从上面的例子可以看出如果函数提升会被变量声明覆盖的话，则第一个console.log(a)就等于undefined。</p><p>我们再来看一个例子，看看num等于多少</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num=foo(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>思考1分钟，觉得num等于多少？<br>实际上的解析过程是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line">num = foo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>印证了函数提升不会被变量声明覆盖，但会被变量赋值覆盖</strong></p><p>最后注意：只有声明的变量和函数才会进行提升，<strong>隐式全局变量不会提升</strong>。</p><p>下面的栗子中，b不会进行变量提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 报错 Uncaught ReferenceError: b is not defined</span></span><br><span class="line">  b = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h2&gt;&lt;p&gt;通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="var" scheme="http://example.com/tags/var/"/>
    
    <category term="function" scheme="http://example.com/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>前端持久化存储</title>
    <link href="http://example.com/2020/12/23/js-storage/"/>
    <id>http://example.com/2020/12/23/js-storage/</id>
    <published>2020-12-23T12:16:04.000Z</published>
    <updated>2020-12-23T13:47:52.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul><li><strong>定义：</strong><br>Cookie是保存在客户机的文本文件（IE保存在本地的一个txt文件中）, 这个文件与特定的 Web 文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用。请求服务器时放在http请求头里面（不论是否需要，都会放在请求头里面）</li><li><strong>为什么需要cookie？</strong><br>HTTP是一种无状态的协议，客户端与服务器建立连接并传输数据，数据传输完成后，连接就会关闭。再次交互数据需要建立新的连接，因此，服务器无法从连接上跟踪会话，也无法知道用户上一次做了什么。如：在网络有时候需要用户登录才进一步操作，用户输入用户名密码登录后，浏览了几个页面，由于HTTP的无状态性，服务器并不知道用户有没有登录。但是有了Cookie，服务器在第一次客户端请求的时候，将cookie保存在客户端，客户端重新请求服务器时会携带cookie（未过期），这样服务器就知道上一次用户做了什么。服务器还会对Cookie信息进行维护，必要时会对Cookie内容进行修改。</li><li><strong>场景：</strong><blockquote><p><strong>保存用户登录状态</strong>：例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。<br><strong>跟踪用户行为</strong>：例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。<br><strong>定制页面</strong>：如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。<br><strong>创建购物车</strong>：正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。 </p></blockquote></li><li><strong>属性：</strong><table><thead><tr><th align="center">序号</th><th align="center">属性</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Expires(http/1.0协议)</td><td align="left">设置Cookie的过期时间</td></tr><tr><td align="center">2</td><td align="center">maxAge(http/1.1协议)</td><td align="left">该Cookie失效的时间，单位秒。是个相对值,相对的是文档第一次被请求时服务器记录的请求时间。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，关闭浏览器即失效。如果为0，表示删除该Cookie。默认为–1。</td></tr><tr><td align="center">3</td><td align="center">path</td><td align="left">cookie能被使用的路径，默认当前路径 /</td></tr><tr><td align="center">4</td><td align="center">domain</td><td align="left">该Cookie变量所属域</td></tr><tr><td align="center">5</td><td align="center">Secure</td><td align="left">指定是否使用HTTPS安全协议发送Cookie。在网络上传输数据之前先将数据加密。默认为false</td></tr><tr><td align="center">6</td><td align="center">httpOnly</td><td align="left">设置cookie是否能通过 js 去访问,防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。默认为false</td></tr><tr><td align="center">7</td><td align="center">size</td><td align="left">cookie的大小</td></tr></tbody></table></li><li><strong>缺点：</strong></li><li>每个特定域名下的cookie数量有限</li><li>存储量太小，只有4KB；</li><li>每次HTTP请求都会发送到服务端，影响获取资源的效率；</li><li>需要自己封装获取、设置、删除cookie的方法；</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>html5 中的 Web Storage 包括了两种存储方式：<strong>sessionStorage</strong> 和<strong>localStorage</strong>。<br><strong>sessionStorage</strong> 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据也随之销毁。<br><strong>localStorage</strong> 用于存储一个域名下的需要永久存在在本地的数据，这些数据可以被一直访问，直到这些数据被删除。<br>因此sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage 存储的数据的生命周期是永久，直到被主动删除，否则数据永远不会过期的。</p><h3 id="sessionStorage-和-localStorage异同"><a href="#sessionStorage-和-localStorage异同" class="headerlink" title="sessionStorage 和 localStorage异同"></a>sessionStorage 和 localStorage异同</h3><ul><li><strong>生命周期</strong>：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。  sessionStorage的生命周期是在仅在当前会话下有效。</li><li><strong>存储大小</strong>：localStorage和sessionStorage的存储数据大小一般都是：5MB  </li><li><strong>存储位置</strong>：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。  </li><li><strong>存储内容类型</strong>：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理  </li><li><strong>获取方式</strong>：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。 </li><li> <strong>应用场景</strong>：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据（令牌）。sessionStorage：敏感账号一次性登录；</li></ul><h2 id="web-storage和cookie的异同"><a href="#web-storage和cookie的异同" class="headerlink" title="web storage和cookie的异同"></a>web storage和cookie的异同</h2><p><strong>共同点：</strong><br><strong>都是保存在浏览器端，且同源的。</strong></p><p><strong>区别：</strong></p><ul><li>存储的大小：cookie：单个cookie保存的数据不能超过4kb；web storage的存储大小5MB</li><li>作用：cookie是用于客户端和服务端间的信息传递；web storage是用于本地大容量存储数据；</li><li>有期时间：cookie可设置失效时间，localstorage除非主动删除；sessionstorage关闭会话窗口失效</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;br&gt;Cookie是保存在客户机的文本文件（IE保存在</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="Cookie" scheme="http://example.com/tags/Cookie/"/>
    
    <category term="localStorage" scheme="http://example.com/tags/localStorage/"/>
    
    <category term="sessionStorage" scheme="http://example.com/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>js-原型-原型链</title>
    <link href="http://example.com/2020/12/21/js-prototype/"/>
    <id>http://example.com/2020/12/21/js-prototype/</id>
    <published>2020-12-21T15:51:09.000Z</published>
    <updated>2020-12-21T16:51:50.071Z</updated>
    
    <content type="html"><![CDATA[<ul><li>构造函数</li><li>原型</li><li>原型链</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>通过 <font color='red'>new</font> 函数名来实例化对象的函数叫构造函数。任何的函数都可以作为构造函数存在。<br>之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要 功能为 初始化对象，特点是和new 一起使用。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">&#x27;孙悟空&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong><font color='red'>f1</font>就是一个构造函数</strong></p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<font color='red'>prototype</font>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。<br>对象具有属性<font color='red'><strong>proto</strong></font>，可称为隐式原型，一个对象的隐式原型指向<font color='red'>构造该对象的构造函数的原型</font>，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f1.__proto__ === Foo.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>方法（<font color='red'>Function</font>）方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（<font color='red'>prototype</font>），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做<font color='red'>constructor</font>，这个属性包含了一个指针，指回原构造函数。</strong></p><ul><li><strong>每个构造函数都有一个prototype原型对象</strong></li><li><strong>prototype原型对象里的constructor指向构造函数本身</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="prototype.jpg" alt="prototype"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们来分析一下上图</p><blockquote><p><strong>1.构造函数Foo()<br>构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。</strong><br><strong>2.原型对象Foo.prototype<br>Foo.prototype保存着实例共享的方法，有一个指针<font color='red'>constructor</font>指回构造函数。</strong><br><strong>3.实例<br><font color='red'>f1和f2</font>是Foo这个对象的两个实例，这两个对象也有属性<font color='red'><strong>proto</strong></font>，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</strong></p></blockquote><p><strong>另外：<br>构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？<br>指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。</strong></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</strong></p><p>举例说明: f1 → Foo → Object ，foo继承Foo，Foo继承Object</p><p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</strong><br><strong><font color='red'>Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有__proto__这个属性。</font></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>大部分参考作者doris的内容，具体可看作者doris<a href="https://www.zhihu.com/question/34183746/answer/58155878">知乎文章</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;原型&lt;/li&gt;
&lt;li&gt;原型链&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;通过 &lt;</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="prototype" scheme="http://example.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>CSS 盒模型</title>
    <link href="http://example.com/2020/12/18/css-box/"/>
    <id>http://example.com/2020/12/18/css-box/</id>
    <published>2020-12-18T11:42:05.000Z</published>
    <updated>2020-12-18T12:43:58.472Z</updated>
    
    <content type="html"><![CDATA[<p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><ul><li>W3C标准盒模型</li><li>IE盒模型</li><li>两种盒模型的区别</li></ul><p>盒子模型<br><img src="box-model.png" alt="盒子模型"></p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong>- 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h2 id="W3C标准盒模型"><a href="#W3C标准盒模型" class="headerlink" title="W3C标准盒模型"></a>W3C标准盒模型</h2><p><img src="test2.jpg" alt="标准盒模型"><br><font color='red'><strong>盒子的内容区域(content) = 设置的width/height</strong></font><br><strong>标准盒模型的宽高</strong><br><font color='red'><strong>width=  content + padding * 2 + border * 2<br>height=  content + padding * 2 + border * 2</strong></font></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#87CEFA</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid<span class="number">#FFA07A</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="test.PNG" alt="标准盒模型"><br>我们点击f12，打开调试页面<br><img src="test1.PNG" alt="标准盒模型"><br>明明我们设置的是宽高为300x200的盒子，发现却是一个360x260的盒子。<br>盒子的宽高：<br><strong>360(width) = 300(content) + 20(padding) * 2 + 10(border) * 2</strong><br><strong>260(height) = 200(content) + 20(padding) * 2 + 10(border) * 2</strong></p><h2 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h2><p><img src="test3.jpg" alt="IE盒模型"><br><font color='red'><strong>盒子的宽高 = 设置的width/height</strong></font></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#FFA07A</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="number">#87CEFA</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    box-sizing: border-box; // 改变盒模型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="test5.PNG" alt="IE盒模型"><br>我们点击f12，打开调试页面<br><img src="test4.PNG" alt="IE盒模型"></p><p>盒子的宽高：<br><strong>300(width) = 240(content) + 20(padding) * 2 + 10(border) * 2</strong><br><strong>200(height) = 140(content) + 20(padding) * 2 + 10(border) * 2</strong></p><h2 id="两种盒模型的区别"><a href="#两种盒模型的区别" class="headerlink" title="两种盒模型的区别"></a>两种盒模型的区别</h2><ul><li>在 标准盒子模型中，width 和 height 指的是<strong>内容区域的宽度和高度</strong>。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li>IE盒子模型中，width 和 height 指的是<strong>内容区域</strong>+<strong>border</strong>+<strong>padding</strong>的宽度和高度。</li></ul><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>如果想要切换盒模型也很简单，这里需要借助css3的box-sizing属性</p><blockquote><ul><li><strong>box-sizing: content-box</strong> 是W3C盒模型</li><li><strong>box-sizing: border-box</strong> 是IE盒模型</li></ul></blockquote><p><strong>box-sizing的默认属性是content-box</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。&lt;br&gt;CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。&lt;br&gt;盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js的执行机制</title>
    <link href="http://example.com/2020/12/15/js-Event-Loop/"/>
    <id>http://example.com/2020/12/15/js-Event-Loop/</id>
    <published>2020-12-15T15:46:41.000Z</published>
    <updated>2020-12-21T16:52:22.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h1><h2 id="为什么js是单线程？"><a href="#为什么js是单线程？" class="headerlink" title="为什么js是单线程？"></a>为什么js是单线程？</h2><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h2 id="为什么要有事件循环？"><a href="#为什么要有事件循环？" class="headerlink" title="为什么要有事件循环？"></a>为什么要有事件循环？</h2><p>因为Javascript在浏览器中是单线程，所以在进行一个延时操作时并不能真的就让进程在原地等待那么久，那样用户的相关操作就“卡死”在哪里了，所以引入了事件循环的机制来，将需要消耗时间的操作“跳过去”，等主线程的操作完成了，再检查任务队列中是否还有任务，然后将任务调出来执行。就这样反复循环执行，所以就叫做事件循环。<br><img src="event.png" alt="Event Loop"><br>导图表达的内容：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;发送成功!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入<strong>Event Table</strong>，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入<strong>Event Queue</strong>。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p><h2 id="事件循环中的setTimeout"><a href="#事件循环中的setTimeout" class="headerlink" title="事件循环中的setTimeout"></a>事件循环中的setTimeout</h2><p>大家对他的第一印象就是<strong>异步</strong>可以延时执行，我们经常这么实现延时3秒执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;延时3秒&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？<br>先看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;执行console&#x27;</span>);</span><br></pre></td></tr></table></figure><p>根据前面我们的结论，setTimeout是<strong>异步</strong>的，应该先执行console.log这个同步任务，所以我们的结论是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行console</span></span><br><span class="line"><span class="comment">//task()</span></span><br></pre></td></tr></table></figure><p>去验证一下，结果正确！<br>然后我们修改一下前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">sleep(<span class="number">10000000</span>)</span><br></pre></td></tr></table></figure><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？<br>这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：</p><ul><li><font color='red'><strong>task()</strong></font>进入Event Table并注册,计时开始。</li><li>执行<font color='red'><strong>sleep</strong></font>函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件<font color='red'><strong>timeout</strong></font>完成，<font color='red'><strong>task()</strong></font>进入<strong>Event Queue</strong>，但是<font color='red'><strong>sleep</strong></font>也太慢了吧，还没执行完，只好等着。</li><li><font color='red'><strong>sleep</strong></font>终于执行完了，<font color='red'><strong>task()</strong></font>终于从<strong>Event Queue</strong>进入了主线程执行。</li></ul><p>上述的流程走完，我们知道<font color='red'><strong>setTimeout</strong></font>这个函数，是经过指定时间后，把要执行的任务(本例中为<font color='red'><strong>task()</strong></font>)加入到<strong>Event Queue</strong>中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><h3 id="setTimeout-fn-0-示例"><a href="#setTimeout-fn-0-示例" class="headerlink" title="setTimeout(fn,0)示例"></a>setTimeout(fn,0)示例</h3><p>我们还经常遇到 <strong>setTimeout(fn,0)</strong> 这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？<br>答案是不会的，<strong>setTimeout(fn,0)</strong> 的含义是：<strong>指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。</strong><br>举例说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>结果：a d c b</strong></p><ul><li> <strong>console.log(‘a’)</strong> 和 <strong>console.log(‘d’)</strong> 进入主线程</li><li> 定时器 <strong>setTimeout</strong> 延迟一段时间执行，顾名思义异步任务进入<strong>Event Queue</strong>中，等待主线程任务执行完毕，再进入主线程执行。</li></ul><p>有人疑惑为什么<strong>c</strong>比<strong>b</strong>先输出？<br><strong>定时器的延迟时间为 0 并不是立刻执行，只是代表相比于其他定时器更早的进入主线程中执行。即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</strong><br>如果宏任务里的settimeout延迟时间不一样，优先执行短的，等短的settimeout整个宏任务执行完了才到长的settimeout<br>因为<strong>c</strong>的延迟时间比<strong>b</strong>短，所以更早进入主线程。</p><h2 id="事件循环中的setInterval"><a href="#事件循环中的setInterval" class="headerlink" title="事件循环中的setInterval"></a>事件循环中的setInterval</h2><p><font color='red'><strong>setTimeout</strong></font> 的孪生兄弟 <font color='red'><strong>setInterval</strong></font>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<font color='red'><strong>setInterval</strong></font> 会每隔指定的时间将注册的函数置入<strong>Event Queue</strong>，如果前面的任务耗时太久，那么同样需要等待。<br>唯一需要注意的一点是，对于 <font color='red'><strong>setInterval(fn,ms)</strong></font> 来说，我们已经知道 <strong>不是</strong> 每过ms秒会执行一次fn，而是每过ms秒，会有fn进入 <strong>Event Queue</strong> 。<br><strong>一旦 <font color='red'>setInterval</font> 的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</strong></p><h2 id="事件循环中的Promise与process-nextTick-callback"><a href="#事件循环中的Promise与process-nextTick-callback" class="headerlink" title="事件循环中的Promise与process.nextTick(callback)"></a>事件循环中的Promise与process.nextTick(callback)</h2><p>除了广义的<strong>同步</strong>任务和<strong>异步</strong>任务，我们对任务有更精细的定义：</p><ul><li><font color='red'><strong>macro-task(宏任务)</strong></font>  ：包括<strong>整体代码script，setTimeout，setInterval</strong></li><li><font color='red'><strong>micro-task(微任务)</strong></font> ：<strong>Promise，process.nextTick</strong></li></ul><p>不同类型的任务会进入对应的<strong>Event Queue</strong>，比如<strong>setTimeout</strong>和<strong>setInterval</strong>会进入相同的<strong>Event Queue</strong>。</p><p><strong>事件循环的顺序，决定js代码的执行顺序。</strong>进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。<br>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;console&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<strong>setTimeout</strong>，那么将其回调函数注册后分发到宏任务<strong>Event Queue</strong>。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<strong>Promise</strong>，<strong>new Promise</strong>立即执行，<strong>then</strong>函数分发到微任务<strong>Event Queue</strong>。</li><li>遇到console.log()，立即执行。</li><li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 <strong>then</strong> 在微任务 <strong>Event Queue</strong> 里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 <strong>Event Queue</strong> 开始。我们发现了宏任务 <strong>Event Queue</strong> 中 <strong>setTimeout</strong> 对应的回调函数，立即执行。</li><li>结束。</li></ul><p>事件循环，宏任务，微任务的关系如图所示：<br><img src="mask.png" alt="mask"></p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>分析一段复杂代码验收成果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第一轮事件循环流程分析如下："><a href="#第一轮事件循环流程分析如下：" class="headerlink" title="第一轮事件循环流程分析如下："></a>第一轮事件循环流程分析如下：</h3><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到 <font color='red'><strong>setTimeout</strong></font> ，其回调函数被分发到宏任务<strong>Event Queue</strong>中。我们暂且记为<font color='red'><strong>setTimeout1</strong></font> 。</li><li>遇到 <font color='red'><strong>process.nextTick()</strong></font> ，其回调函数被分发到微任务<strong>Event Queue</strong>中。我们记为<font color='red'><strong>process1</strong></font> 。</li><li>遇到 <font color='red'><strong>Promise</strong></font>，<font color='red'><strong>new Promise</strong></font>直接执行，输出7。<font color='red'><strong>then1</strong></font>被分发到微任务<strong>Event Queue</strong>中。我们记为<font color='red'><strong>then1</strong></font> 。</li><li>又遇到了 <font color='red'><strong>setTimeout</strong></font> ，其回调函数被分发到宏任务Event Queue中，我们记为<font color='red'><strong>setTimeout2</strong></font> 。</li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout1</td><td align="center">process1</td></tr><tr><td align="center">setTimeout2</td><td align="center">then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各<strong>Event Queue</strong>的情况，此时已经输出了1和7。</li><li>我们发现了 <font color='red'><strong>process1</strong></font> 和 <font color='red'><strong>then1</strong></font> 两个微任务。</li><li>执行 <font color='red'><strong>process1</strong></font>,输出6。</li><li>执行 <font color='red'><strong>then1</strong></font>，输出8。<br>第一轮事件循环正式结束，结果是输出<strong>1，7，6，8</strong>。</li></ul><h3 id="第二轮事件循环流程分析如下："><a href="#第二轮事件循环流程分析如下：" class="headerlink" title="第二轮事件循环流程分析如下："></a>第二轮事件循环流程分析如下：</h3><p><strong>循环从setTimeout1宏任务开始</strong></p><ul><li>首先输出2。接下来遇到了 <font color='red'><strong>process.nextTick()</strong></font> ，同样将其分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>process2</strong></font> 。<font color='red'><strong>new Promise</strong></font> 立即执行输出4，then也分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>then2</strong></font> 。</li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout2</td><td align="center">process2</td></tr><tr><td align="center"></td><td align="center">then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有<font color='red'><strong>process2</strong></font>和<font color='red'><strong>then2</strong></font>两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，<br>第二轮输出<strong>2，4，3，5</strong>。</li></ul><h3 id="第三轮事件循环流程分析如下："><a href="#第三轮事件循环流程分析如下：" class="headerlink" title="第三轮事件循环流程分析如下："></a>第三轮事件循环流程分析如下：</h3><ul><li><p>此时只剩<font color='red'><strong>setTimeout2</strong></font>了，执行。</p></li><li><p>直接输出9。</p></li><li><p>将 <font color='red'><strong>process.nextTick()</strong></font>分发到微任务<strong>Event Queue</strong>中。记为<font color='red'><strong>process3</strong></font>。</p></li><li><p>直接执行 <font color='red'><strong>new Promise</strong></font>，输出11。</p></li><li><p>将then分发到微任务<strong>Event Queue</strong>中，记为<font color='red'><strong>then3</strong></font>。</p><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center"></td><td align="center">process3</td></tr><tr><td align="center"></td><td align="center">then3</td></tr></tbody></table></li><li><p>第三轮事件循环宏任务执行结束，执行两个微任务<font color='red'><strong>process3</strong></font>和<font color='red'><strong>then3</strong></font>。</p></li><li><p>输出10。</p></li><li><p>输出12。</p></li><li><p>第三轮事件循环结束，</p></li></ul><p>第三轮输出<strong>9，11，10，12</strong>。</p><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><p><strong>大部分转载作者-ssssyoki的内容，具体可看作者-ssssyoki<a href="https://juejin.cn/post/6844903512845860872#heading-4">掘金推文</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS事件循环&quot;&gt;&lt;a href=&quot;#JS事件循环&quot; class=&quot;headerlink&quot; title=&quot;JS事件循环&quot;&gt;&lt;/a&gt;JS事件循环&lt;/h1&gt;&lt;h2 id=&quot;为什么js是单线程？&quot;&gt;&lt;a href=&quot;#为什么js是单线程？&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS new操作符</title>
    <link href="http://example.com/2020/08/28/js-new/"/>
    <id>http://example.com/2020/08/28/js-new/</id>
    <published>2020-08-27T19:31:25.000Z</published>
    <updated>2020-12-14T03:53:29.580Z</updated>
    
    <content type="html"><![CDATA[<p><strong>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</strong></p><ul><li>new操作符做了什么？</li><li>模拟实现JS的new操作符</li></ul><h2 id="new操作符做了什么？"><a href="#new操作符做了什么？" class="headerlink" title="new操作符做了什么？"></a>new操作符做了什么？</h2><p><strong>new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象</strong></p><ol><li>创建一个空的对象</li><li>将空对象的原型prototype指向构造函数的原型</li><li>将空对象作为构造函数的上下文（改变this指向）</li><li>确保返回的是对象</li></ol><h3 id="构造函数返回值的判断-对第4步的解析"><a href="#构造函数返回值的判断-对第4步的解析" class="headerlink" title="构造函数返回值的判断(对第4步的解析)"></a>构造函数返回值的判断(对第4步的解析)</h3><blockquote><p>一般情况下构造函数没有返回值，但是作为函数，是可以有返回值的。<br>那么在构造函数有返回值的情况下，new操作符做了什么？</p></blockquote><p>先看两个例子：<br>注意一下两个返回值的差异</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return undefined/NaN/&#x27;string&#x27;/null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;快乐每一天&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// &#123; name:&#x27;快乐每一天&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>:<span class="number">12</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;快乐每一天&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// &#123; age:12 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>在new的时候，会对构造函数的返回值做一些判断：</p><blockquote><ol><li>如果返回值是基础数据类型，则忽略返回值；</li><li>如果返回值是引用数据类型，则使用return 的返回，也就是new操作符无效；</li></ol></blockquote><h2 id="模拟实现JS的new操作符"><a href="#模拟实现JS的new操作符" class="headerlink" title="模拟实现JS的new操作符"></a>模拟实现JS的new操作符</h2><h3 id="proto和prototype区别"><a href="#proto和prototype区别" class="headerlink" title="proto和prototype区别"></a>proto和prototype区别</h3><blockquote><p><strong>方法</strong>（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性proto，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。<br><strong>方法</strong>这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</p></blockquote><p><img src="proto.jpg" alt="proto"></p><h3 id="分析图片"><a href="#分析图片" class="headerlink" title="分析图片"></a>分析图片</h3><blockquote><p><strong>1. 构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。<br>2. 原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。<br>3. 实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</strong></p></blockquote><p>另外：构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。<br><strong>原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。</strong><br>实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，<strong>指向构造函数的原型对象</strong>，这样子就可以像上面1所说的访问原型对象的所有方法啦。<br>另外：<strong>构造函数</strong>Foo()除了是方法，也是对象啊，它也有proto属性，指向谁呢？<br><strong>指向它的构造函数的原型对象</strong>。函数的构造函数不就是Function嘛，因此这里的proto指向了Function.prototype。<br>其实除了Foo()，Function(), Object()也是一样的道理。<br><strong>原型对象</strong>也是对象啊，它的proto属性，又指向谁呢？<br>同理，<strong>指向它的构造函数的原型对象</strong>。这里是Object.prototype.最后，Object.prototype的proto属性指向null。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p><strong>对象有属性proto,指向该对象的构造函数的原型对象。<br>方法除了有属性proto,还有属性prototype，prototype指向该方法的原型对象。</strong></p></blockquote><h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 先创建一个空的新对象<br>2. 因为 obj 对象需要访问到构造函数原型链上的属性，所以空对象的proto需要指向后遭函数的prototype<br>3. 将obj绑定到构造函数中，并传入其余参数（改变this指向）<br>4. 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值</strong><br>接下来我们来使用下该函数，看看是否和 new 操作符一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = create(Test, <span class="string">&#x27;yck&#x27;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// &#x27;yck&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age) <span class="comment">// 26</span></span><br><span class="line">a.sayName() <span class="comment">// &#x27;yck&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new操作符做了什么？&lt;/li&gt;
&lt;li&gt;模拟实现JS的new操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;new操作符做了什么？&quot;&gt;</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="new" scheme="http://example.com/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>JS事件的三个阶段</title>
    <link href="http://example.com/2020/08/25/js-event/"/>
    <id>http://example.com/2020/08/25/js-event/</id>
    <published>2020-08-24T19:18:19.000Z</published>
    <updated>2020-12-14T03:53:21.899Z</updated>
    
    <content type="html"><![CDATA[<p><strong>事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段。<br>事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这个路径回溯到文档跟节点。</strong><br><img src="event.png" alt="事件"></p><ul><li>捕获阶段</li><li>目标阶段</li><li>冒泡阶段</li><li>事件代理</li></ul><h2 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h2><p><strong>当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。</strong></p><p><img src="event3.png" alt="事件捕获"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#ancestors</span>&#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: red;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#father</span>&#123;</span></span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background: blue;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#son</span>&#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: green;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ancestors&quot;</span>&gt;</span>祖先</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span>父亲</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span>儿子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ancestors&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;祖先&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;父亲&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;son&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;儿子&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="event.jpg" alt="事件捕获"><br><img src="event1.jpg" alt="事件捕获"><br><strong>当我点击儿子的时候，就会从最外层开始触发，因为没有对document/html/body进行监听，所以从祖先开始触发，直到目标节点</strong></p><h2 id="目标阶段"><a href="#目标阶段" class="headerlink" title="目标阶段"></a>目标阶段</h2><p><strong>当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发，然后会逆向回流，直到传播至最外层的文档节点。</strong></p><h2 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h2><p><strong>事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点（文档）。所有现代浏览器都支持事件冒泡，并且会将事件一直冒泡到window对象</strong><br><img src="event2.png" alt="事件冒泡"></p><p>示例（html代码同上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ancestors&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;祖先&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;父亲&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;son&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;儿子&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="event2.jpg" alt="事件冒泡"><br><strong>当点击儿子的时候，事件在儿子元素上触发后，开始逐级向上冒泡。</strong></p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><blockquote><p>事件代理就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。<br>举个例子：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。<br>这里其实还有2层意思的：<br>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p></blockquote><h3 id="为什么要用事件代理"><a href="#为什么要用事件代理" class="headerlink" title="为什么要用事件代理"></a>为什么要用事件代理</h3><p><strong>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件代理，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</strong></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>比如现在我们需要对一个100行10列表格里的每一个td进行事件监听，当点击某个表格的时候则变为可编辑状态。如果把事件处理器加到这1000个单元格会产生一个很大的性能问题，并且有可能导致内存泄露甚至是浏览器的崩溃。相反地，使用事件代理，你只需要把一个事件处理器添加到table元素上就可以了，这个函数可以把点击事件给截下来，并且判断出是哪个单元格被点击了。<br><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>6<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>7<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>8<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>9<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;table&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">table.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.eventPhase) <span class="comment">// 判断当前的事件阶段（1：捕获，2：目标，3：冒泡）</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.nodeName.toLowerCase() === <span class="string">&#x27;td&#x27;</span>)&#123; <span class="comment">// 只有点击的是td才会触发</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.target)</span><br><span class="line">  <span class="built_in">console</span>.log(event.currentTarget) <span class="comment">// 监听器触发事件的元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="event3.jpg" alt="事件代理"><br><img src="event4.jpg" alt="事件代理"><br>当我点击5的时候，td就会通过事件冒泡到绑定的触发器table元素，然后获取到你点击的元素。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>通过刚才的对比介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点： 1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。 2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。 3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段。&lt;br&gt;事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动</title>
    <link href="http://example.com/2020/08/22/css-clear-float/"/>
    <id>http://example.com/2020/08/22/css-clear-float/</id>
    <published>2020-08-21T19:09:35.000Z</published>
    <updated>2020-12-14T03:52:37.348Z</updated>
    
    <content type="html"><![CDATA[<p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫<strong>浮动溢出</strong>，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br><strong>清除浮动的本质：主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题。</strong></p><ul><li>示例</li><li>方法</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    background-color: darksalmon;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line">    background-color: aquamarine;</span><br><span class="line">    float: right;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="float.jpg" alt="float"><br><strong>容器没有包含浮动元素</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="使用带clear属性的块级元素-不推荐"><a href="#使用带clear属性的块级元素-不推荐" class="headerlink" title="使用带clear属性的块级元素(不推荐)"></a>使用带clear属性的块级元素(不推荐)</h3><blockquote><p><strong>在浮动元素后面添加一个带clear属性的块级元素<br>优点：简单，代码少，浏览器支持好<br>缺点：如果页面浮动布局多，则需要很多空标签</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.clear</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 添加 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="clear.jpg" alt="清除浮动"></p><h3 id="使用CSS的overflow属性-不推荐"><a href="#使用CSS的overflow属性-不推荐" class="headerlink" title="使用CSS的overflow属性(不推荐)"></a>使用CSS的overflow属性(不推荐)</h3><blockquote><p><strong>给浮动元素的容器添加overflow属性<br>优点：不存在结构和语义化问题，代码量极少 　　<br>缺点：多个嵌套后，firefox某些情况会造成内容全选；</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line"><span class="css">    <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>; <span class="comment">/*添加,或者overflow:auto;*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用CSS的-after伪元素-推荐使用"><a href="#使用CSS的-after伪元素-推荐使用" class="headerlink" title="使用CSS的:after伪元素(推荐使用)"></a>使用CSS的:after伪元素(推荐使用)</h3><blockquote><p><strong>给浮动元素的容器添加一个class，然后给这个class添加一个:after伪元素实现元素末尾添加一个隐藏的块级元素清理浮动。<br>优点：兼容性好<br>缺点：ie6-7不支持伪元素：after</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123; <span class="comment">/*添加*/</span></span></span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: block;</span><br><span class="line">      height: 0;</span><br><span class="line">      clear: both;</span><br><span class="line">      visibility: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用before和after双伪元素清除浮动-推荐使用"><a href="#使用before和after双伪元素清除浮动-推荐使用" class="headerlink" title="使用before和after双伪元素清除浮动(推荐使用)"></a>使用before和after双伪元素清除浮动(推荐使用)</h3><p>**给浮动元素的容器添加一个class，然后给这个class添加一个:after伪元素实现元素末尾添加一个隐藏的块级元素清理浮动。<br>**</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after.clearfix</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: table;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line">      clear: both;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="容器浮动-不推荐"><a href="#容器浮动-不推荐" class="headerlink" title="容器浮动(不推荐)"></a>容器浮动(不推荐)</h3><p>**让浮动元素的容器也浮动起来<br>优点：代码少<br>缺点：会导致整个页面大部分都处于浮动状态，容易出现问题 **</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    background-color: gray;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="container.jpg" alt="清除浮动"><br><strong>因为没给容器设置宽度</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫&lt;strong&gt;浮动溢出&lt;/st</summary>
      
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
    <category term="float" scheme="http://example.com/tags/float/"/>
    
  </entry>
  
  <entry>
    <title>压缩算法</title>
    <link href="http://example.com/2020/08/21/js-compress/"/>
    <id>http://example.com/2020/08/21/js-compress/</id>
    <published>2020-08-20T19:05:28.000Z</published>
    <updated>2020-12-14T03:53:17.671Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目描述</li><li>思路</li><li>代码</li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为m|S，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入第一行包含一个字符串s，代表压缩后的字符串。<br>S的长度&lt;=1000;<br>S仅包含大写字母、[、]、|;<br>解压后的字符串长度不超过100000;<br>压缩递归层数不超过10层;</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p><strong>输出一个字符串，代表解压后的字符串。</strong></p></blockquote><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p><strong>HG[3|B[2|CA]]F</strong></p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p><strong>HGBCACABCACABCACAF<br>HG[3|B[2|CA]]F−&gt;HG[3|BCACA]F−&gt;HGBCACABCACABCACAF</strong></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过<strong>递归</strong>的方法实现，每次寻找最内层的[n|xx]通过截取n和xx字符串，将[n|xx]解压并替换，再将当前的字符串递归，直至字符串没有[n|xx]，输出字符串。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\[\d+\|[A-Z]*\]/</span> <span class="comment">// 匹配最内层的[n|xxx]的正则表达式</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/\|/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str1 = reg.exec(str)</span><br><span class="line">  <span class="keyword">if</span> (!str1)&#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> substr = str1[<span class="number">0</span>] <span class="comment">// 最内层的[n|xxx]</span></span><br><span class="line">  <span class="keyword">const</span> index = str1.index <span class="comment">// 最内层的[n|xxx]索引</span></span><br><span class="line">  <span class="keyword">const</span> mindex = reg2.exec(substr).index <span class="comment">// 代表&#x27;|&#x27;符号的index</span></span><br><span class="line">  <span class="keyword">const</span> num = <span class="built_in">Number</span>(substr.slice(<span class="number">1</span>,mindex)) <span class="comment">//n</span></span><br><span class="line">  <span class="keyword">const</span> sonstr = substr.slice(mindex+<span class="number">1</span>,-<span class="number">1</span>) <span class="comment">// xxx</span></span><br><span class="line">  <span class="keyword">const</span> str2 = str.replace(reg,sonstr.repeat(num))</span><br><span class="line">  compress(str2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;题目描述&lt;/li&gt;
&lt;li&gt;思路&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;小Q想要给他的朋友发送一个</summary>
      
    
    
    
    <category term="递归" scheme="http://example.com/categories/%E9%80%92%E5%BD%92/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>数组扁平化</title>
    <link href="http://example.com/2020/08/12/array-flat/"/>
    <id>http://example.com/2020/08/12/array-flat/</id>
    <published>2020-08-11T18:58:28.000Z</published>
    <updated>2020-12-14T03:52:22.508Z</updated>
    
    <content type="html"><![CDATA[<p>数组扁平化是指将一个多维数组变为一维数组<br>[1, [2, 3, [4, 5]]] ——&gt; [1, 2, 3, 4, 5]</p><ul><li>递归法</li><li>reduce 实现</li><li>split法</li><li>正则匹配</li><li>ES6</li></ul><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p><strong>通过判断当前是否是数组，然后通过递归实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unction flatten (arr) &#123;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line">arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">res = res.concat(flatten(item))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line">arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">res = res.concat(flatten(item))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="split法"><a href="#split法" class="headerlink" title="split法"></a>split法</h2><p>如果一个需要实现扁平化的数组里都是<strong>数字</strong>类型的话可以用下面这种方法&gt;数字类型的话可以用下面这种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    arr.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function">(<span class="params">item</span>) =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Number</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p><strong>通过正则匹配将‘[’或者‘]’符号替换成空字符串</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="string">`[<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(array).replace(<span class="regexp">/\[|]/g</span>,<span class="string">&#x27;&#x27;</span>)&#125;</span>]`</span>)</span><br><span class="line">handle(array)</span><br></pre></td></tr></table></figure><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="flat（）"><a href="#flat（）" class="headerlink" title="flat（）"></a>flat（）</h3><p><strong>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>注意flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p><h3 id="或者使用Infinity关键字"><a href="#或者使用Infinity关键字" class="headerlink" title="或者使用Infinity关键字"></a>或者使用<strong>Infinity</strong>关键字</h3><blockquote><p>Infinity(无穷大)在 JS 中是一个特殊的数字，它的特性是：它比任何有限的数字都大<br>JS中的Infinity表示无穷数的概念。 任何有限数均小于Infinity，而任何有限数均大于-Infinity。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.flat(<span class="literal">Infinity</span>)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>实现方法有很多，原理基本一样，只要你对js熟悉，可以有很多实现方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组扁平化是指将一个多维数组变为一维数组&lt;br&gt;[1, [2, 3, [4, 5]]] ——&amp;gt; [1, 2, 3, 4, 5]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归法&lt;/li&gt;
&lt;li&gt;reduce 实现&lt;/li&gt;
&lt;li&gt;split法&lt;/li&gt;
&lt;li&gt;正则匹配&lt;/li&gt;</summary>
      
    
    
    
    <category term="array" scheme="http://example.com/categories/array/"/>
    
    
    <category term="array" scheme="http://example.com/tags/array/"/>
    
    <category term="flat" scheme="http://example.com/tags/flat/"/>
    
  </entry>
  
  <entry>
    <title>js实现最优打字策略</title>
    <link href="http://example.com/2020/08/05/js-optimal-write/"/>
    <id>http://example.com/2020/08/05/js-optimal-write/</id>
    <published>2020-08-04T18:52:23.000Z</published>
    <updated>2020-12-14T03:53:33.900Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道京东校招的笔试题目，有两种实现方式，最好的实现方式是通过贪心算法，本篇还未通过贪心算法实现，后续会继续实现。</p><ul><li>题目描述</li><li>思路</li><li>代码</li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在英文的输入中，我们经常会遇到大小写切换的问题，频繁切换大小写会增加我们的按键次数，也会降低我们的打字效率。 众所周知，切换大小写有两种方式：</p><ul><li>一种是按下”caps locks”，也就是大写锁定键，这样一来，之后的输入模式都会被切换。</li><li>另一种是同时按下shift和需要打印的字母，可以临时切换大小写（算作按下两个键）。<br>已知初始状态下，打字模式是小写，现在给出需要打印的字符串（区分大小写），请你计算出最少需按键多少次才能打印出来。</li></ul><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p><strong>输入第一行仅包含一个正整数n，表示字符串的长度（1&lt;=n&lt;=1000000)<br>输入第二行包含一个长度为n的字符串，仅包含大小写字母</strong></p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p><strong>输出仅包含一个正整数，即最少的按键次数。</strong></p></blockquote><h3 id="样例输入："><a href="#样例输入：" class="headerlink" title="样例输入："></a>样例输入：</h3><blockquote><p><strong>6<br>AaAAAA</strong></p></blockquote><h3 id="样例输出："><a href="#样例输出：" class="headerlink" title="样例输出："></a>样例输出：</h3><blockquote><p><strong>8</strong></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这是一道值得思考的题</strong></p><ul><li>如果当前是小写模式，并且当前字母是小写，那么直接加一，这样最省事。</li><li>如果当前是小写模式，而当前字母是大写，这样就有两种选择了。</li></ul><ol><li>按下caps lock键，切换到大写模式</li><li>同时按下shift键和当前字母。</li></ol><ul><li><p>那么哪种模式好呢？</p><blockquote><p>这就需要看一看它的下一个字符，如果仍然为大写，那么当然按下caps lock更好，并切换成当前为大写模式；<br>如果为小写，那么按下shift最好。</p></blockquote></li><li><p>大写反之</p></li></ul><p><strong>注意点</strong></p><ul><li>大写和小写总共两种状态，我们可以用0表示小写，1表示大写。</li><li>对最后一个字符进行处理，if i == len(s)-1: …，这样只要没到最后一个字符，就可以在后面通过判断i 和 i+1来处理。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="简单逻辑做法"><a href="#简单逻辑做法" class="headerlink" title="简单逻辑做法"></a>简单逻辑做法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUpper</span> (<span class="params">code</span>) </span>&#123; <span class="comment">// 判断字母是否为大写</span></span><br><span class="line">  <span class="keyword">return</span> code === code.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMin</span>(<span class="params">len,arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span> <span class="comment">// 按下次数</span></span><br><span class="line">  <span class="keyword">var</span> status = <span class="number">0</span> <span class="comment">// 0代表当前状态为小写 1代表大写</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isUpper(<span class="built_in">String</span>(arr[i])))&#123; <span class="comment">// 如果是大写</span></span><br><span class="line">      <span class="keyword">if</span> (status === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (isUpper(<span class="built_in">String</span>(arr[i + <span class="number">1</span>])) &amp;&amp; i !== (len-<span class="number">1</span>))&#123; <span class="comment">// 判断大写的字母是否连续</span></span><br><span class="line">          status = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        num += <span class="number">2</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 如果是小写</span></span><br><span class="line">      <span class="keyword">if</span> (status === <span class="number">0</span>)&#123;</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num += <span class="number">2</span></span><br><span class="line">        status = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="string">&#x27;AAAaAAaAaaA&#x27;</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="string">&#x27;AaAAAA&#x27;</span></span><br><span class="line">checkMin(<span class="number">10</span>,arr) <span class="comment">// 15</span></span><br><span class="line">checkMin(<span class="number">7</span>,arr1) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一道京东校招的笔试题目，有两种实现方式，最好的实现方式是通过贪心算法，本篇还未通过贪心算法实现，后续会继续实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题目描述&lt;/li&gt;
&lt;li&gt;思路&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>作用域var和let和const的区别</title>
    <link href="http://example.com/2020/06/03/es6-let-const-var/"/>
    <id>http://example.com/2020/06/03/es6-let-const-var/</id>
    <published>2020-06-02T18:43:45.000Z</published>
    <updated>2020-12-14T03:52:59.908Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 之前 JavaScript没有块级作用域,只有<strong>全局作用域</strong>和<strong>函数作用域</strong>。ES6的到来，为我们提供了<strong>‘块级作用域’</strong>,可通过新增命令let和const来体现。</p><ul><li>作用域(Scope)</li><li>var和let和const的区别</li></ul><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><p><strong>作用域是可访问变量的集合。</strong></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">&quot;内层变量&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Fun();</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure><p><img src="test1.JPG" alt="scope"><br>从上面的例子中可以看出，因在全局作用域里没有声明value变量，所以在全局作用域下取值会报错。简单理解:<strong>作用域就像一个独立的区域，让变量不会外泄。</strong></p><h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --全局作用域的变量声明--</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">&quot;外层变量1&quot;</span></span><br><span class="line"><span class="keyword">var</span> outVariable = <span class="string">&#x27;外层变量2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作用域</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">&quot;内层变量1&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">&#x27;内层变量2&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;可以访问到&#x27;</span> + outVariable)</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fun();</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 不同作用域同名变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable);</span><br></pre></td></tr></table></figure><p><img src="test2.JPG" alt="scope"><br>从上面的例子可以看出函数作用域内的value变量和全局作用域的value并不会冲突。而且外层作用域不能访问到内层的变量，而内层可以访问到外层的变量，所以<br><strong>隔离变量，不同作用域下同名变量不会有冲突。<br>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。</strong></p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p><strong>ES6中新增了块级作用域，使用let声明的变量只能在块级作用域里访问，有<font color='red'>“暂时性死区”</font>的特性（也就是说声明前不可用）。</strong></p><p>块作用域由 { } 包括，主要是以下几种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件语句</span></span><br><span class="line"><span class="keyword">if</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch语句</span></span><br><span class="line"><span class="keyword">switch</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for / while循环语句</span></span><br><span class="line"><span class="keyword">for</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try...catch语句</span></span><br><span class="line"><span class="keyword">try</span> () <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单大括号</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意: 对象的大括号内不是一个块级作用域, 因为它里面不能直接声明变量;</strong></p><h2 id="var和let和const的区别"><a href="#var和let和const的区别" class="headerlink" title="var和let和const的区别"></a>var和let和const的区别</h2><ul><li><strong>var</strong>定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。且存在<strong>变量提升</strong>现象</li><li><strong>let</strong>定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不存在变量提升现象</li><li><strong>const</strong>用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> c = <span class="number">2</span></span><br><span class="line">      <span class="keyword">const</span> aa = <span class="number">6</span></span><br><span class="line">      <span class="keyword">const</span> cc <span class="comment">//报错</span></span><br><span class="line">      <span class="built_in">console</span>.log(c); <span class="comment">// 2</span></span><br><span class="line">      <span class="comment">// 可见，let能在块作用域里访问</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// 可见，通过var定义的变量可以跨块作用域访问到。</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(c); <span class="comment">// 报错：c is not defined</span></span><br><span class="line">  <span class="comment">//可见，通过let定义的变量不能跨块访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">4</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 报错</span></span><br><span class="line">  <span class="comment">// 可见，通过var定义的变量不能跨函数作用域访问到</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(d);</span><br><span class="line">  <span class="comment">//可见，通过let定义的变量不能跨函数访问</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ES6 之前 JavaScript没有块级作用域,只有&lt;strong&gt;全局作用域&lt;/strong&gt;和&lt;strong&gt;函数作用域&lt;/strong&gt;。ES6的到来，为我们提供了&lt;strong&gt;‘块级作用域’&lt;/strong&gt;,可通过新增命令let和const来体现。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="es6" scheme="http://example.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://example.com/tags/es6/"/>
    
    <category term="let" scheme="http://example.com/tags/let/"/>
    
    <category term="const" scheme="http://example.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>JS获取URL中参数值</title>
    <link href="http://example.com/2020/06/02/js-getUrl/"/>
    <id>http://example.com/2020/06/02/js-getUrl/</id>
    <published>2020-06-01T18:38:41.000Z</published>
    <updated>2020-12-14T03:53:25.859Z</updated>
    
    <content type="html"><![CDATA[<p>当你进行表单提交用到get的方式的时候，经常会需要在跳转页面中获取URL中的参数，所以本篇就介绍获取URL参数的两种方法：</p><ul><li>正则法</li><li>split拆分法</li></ul><h2 id="正则法"><a href="#正则法" class="headerlink" title="正则法"></a>正则法</h2><p><strong>通过正则表达式对URL进行匹配</strong></p><h3 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetQueryString</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;(^|&amp;)&#x27;</span> + name + <span class="string">&#x27;=([^&amp;]*)(&amp;|$)&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);<span class="comment">//匹配URL的&#x27;?&#x27;符之后的正则表达式</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分函数解析"><a href="#部分函数解析" class="headerlink" title="部分函数解析"></a>部分函数解析</h3><blockquote><p><strong>RegExp()</strong><br>RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。<br><strong>substr()</strong><br>在字符串中抽取从 start 下标开始的指定数目的字符。<br><strong>unescape()</strong><br>对通过 escape() 编码的字符串进行解码。</p></blockquote><h2 id="split拆分法"><a href="#split拆分法" class="headerlink" title="split拆分法"></a>split拆分法</h2><h3 id="函数代码-1"><a href="#函数代码-1" class="headerlink" title="函数代码"></a>函数代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetQueryValue</span>(<span class="params">queryName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> query = <span class="built_in">unescape</span>(<span class="built_in">window</span>.location.search.substr(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> vars = query.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> pair = vars[i].split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pair[<span class="number">0</span>] == queryName) &#123;</span><br><span class="line">            <span class="keyword">return</span> pair[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当你进行表单提交用到get的方式的时候，经常会需要在跳转页面中获取URL中的参数，所以本篇就介绍获取URL参数的两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则法&lt;/li&gt;
&lt;li&gt;split拆分法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正则法&quot;&gt;&lt;a href=&quot;#正则法&quot; c</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://example.com/2020/05/28/vue-life/"/>
    <id>http://example.com/2020/05/28/vue-life/</id>
    <published>2020-05-27T18:15:55.000Z</published>
    <updated>2020-12-14T03:53:46.343Z</updated>
    
    <content type="html"><![CDATA[<p>Vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。</p><ul><li>vue生命周期</li><li>代码详解</li></ul><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue-life"></p><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不 同阶段添加自己的代码的机会。<br>如下是Vue生命周期的所有钩子函数</p><p><strong>beforeCreate(创建前)<br>created(创建后)<br>beforeMount(挂载前)<br>mounted(挂载后)<br>beforeUpdate(更新前)<br>uptaded(更新后)<br>beforeDestory(销毁前)<br>destoryed(销毁后)</strong></p><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p><strong>测试代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue的生命周期详解<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;beforeCreate&#x27;</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;Created&#x27;</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;beforeMount&#x27;</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,<span class="string">&#x27;mounted&#x27;</span>)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>控制台输出结果</strong><br><img src="test.JPG" alt="控制台输出结果"></p><p>通过控制台的输出结果可以看到vue实例创建的过程中调用的钩子函数以及顺序</p><h3 id="beforeCreate-创建前"><a href="#beforeCreate-创建前" class="headerlink" title="beforeCreate(创建前)"></a>beforeCreate(创建前)</h3><blockquote><p><strong>（beforeCreate钩子函数）在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用，此时的数据观察和事件机制都未形成，不能获得DOM节点。</strong></p></blockquote><h3 id="created-创建后"><a href="#created-创建后" class="headerlink" title="created(创建后)"></a>created(创建后)</h3><blockquote><p><strong>在这个阶段vue实例已经创建，但仍然不能获取DOM元素。<br>数据已经和data属性进行绑定（可以改变data属性的值，但不会触发其他钩子函数，可以在这里对初始数据的获取。）</strong></p></blockquote><p><font color='red'><strong>注意</strong></font><br><strong>如果要在此阶段中进行dom操作，就要将操作都放在 Vue.nextTick() 的回调函数中，因为created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick() 的回调函数中。</strong></p><p>我们在created钩子函数中加入如下语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;font-size:20px&quot;</span>,vm.$el.textContent)</span><br></pre></td></tr></table></figure><p><img src="created_error.JPG" alt="控制台输出结果"></p><p><strong>用Vue.nextTick将操作dom元素的语句放进其回调函数中就有效果。</strong></p><h3 id="beforeMount-载入前"><a href="#beforeMount-载入前" class="headerlink" title="beforeMount(载入前)"></a>beforeMount(载入前)</h3><blockquote><p><strong>在这个阶段首先判断vue实例中有没有el选项，有则继续编译，否则停止生命周期，直到vue实例上调用vm.$mount(el)<br>如果有el，再判断是否有template参数，有则将其当作模板编译成render函数，否则把外部HTML作为模板编译。template中的模板优先级高于outer HTML模板。</strong></p></blockquote><p><strong>调用vm.$mount(el)</strong></p><p><img src="beforeMount.png" alt="beforeMount"></p><p><strong>在控制台里调用vm.$mount(el)之后生命周期则继续</strong><br>测试优先级的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;这是外部的html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;this is createElement&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span> +<span class="string">&#x27;这是在template中的&#x27;</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>当render函数存在时，页面显示</strong><br><img src="test2.JPG" alt="beforeMount"><br><strong>当render函数注释掉，template存在时，页面显示</strong><br><img src="test3.JPG" alt="beforeMount"><br><strong>当把render函数和template注释掉时，页面显示</strong><br><img src="test4.JPG" alt="beforeMount"></p><p><strong>综合排名优先级：<font color='red'>render函数选项 &gt; template选项 &gt; outer HTML</font></strong></p><h3 id="mounted-载入后"><a href="#mounted-载入后" class="headerlink" title="mounted(载入后)"></a>mounted(载入后)</h3><blockquote><p><strong>载入后html已经渲染(ajax请求可以放在这个函数中)，把vue实例中的data里的message挂载到BOM节点中去<br>实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。</strong></p></blockquote><h3 id="beforeUpdate-更新前-和updated-更新后"><a href="#beforeUpdate-更新前-和updated-更新后" class="headerlink" title="beforeUpdate(更新前)和updated(更新后)"></a>beforeUpdate(更新前)和updated(更新后)</h3><blockquote><p><strong>当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。</strong></p></blockquote><p>更改data数据输出结果<br><img src="update.png" alt="beforeMount"></p><h3 id="beforeDestroy-销毁前"><a href="#beforeDestroy-销毁前" class="headerlink" title="beforeDestroy(销毁前)"></a>beforeDestroy(销毁前)</h3><blockquote><p><strong>实例销毁之前调用。在这一步，实例仍然完全可用。</strong></p></blockquote><h3 id="destroyed-销毁后"><a href="#destroyed-销毁后" class="headerlink" title="destroyed(销毁后)"></a>destroyed(销毁后)</h3><blockquote><p><strong>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vue生命周期&lt;/li&gt;
&lt;li&gt;代码详解&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JS快速排序算法</title>
    <link href="http://example.com/2020/05/19/sort-quick/"/>
    <id>http://example.com/2020/05/19/sort-quick/</id>
    <published>2020-05-18T17:12:36.000Z</published>
    <updated>2020-12-14T03:51:14.490Z</updated>
    
    <content type="html"><![CDATA[<ul><li>为什么选择快速排序？</li><li>实现思路</li><li>代码实现</li><li>总结</li></ul><h2 id="为什么选择快速排序？"><a href="#为什么选择快速排序？" class="headerlink" title="为什么选择快速排序？"></a>为什么选择快速排序？</h2><p>相比传统的排序算法（for循环嵌套），时间复杂度由**O(n²) =&gt; O(logn)**。当数据量大的时候就会体现出快排与传统的排序速度的差异，下面我来实现快排的一种方法。</p><h2 id="各大排序算法比较"><a href="#各大排序算法比较" class="headerlink" title="各大排序算法比较"></a>各大排序算法比较</h2><table>  <tbody><tr>    <th rowspan="2">类别</th>    <th rowspan="2">排序方法</th>    <th colspan="3">时间复杂度</th>    <th>空间复杂度</th>    <th rowspan="2">稳定性</th>  </tr>  <tr>    <td>平均情况</td>    <td>最好情况</td>    <td>最坏情况</td>    <td>辅助存储</td>  </tr>  <tr>    <td rowspan="2">插入排序</td>    <td>直接插入</td>    <td>O(n²)</td>    <td>O(n)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>稳定</td>  </tr>  <tr>    <td>Shell排序</td>    <td>O(n^1.3)</td>    <td>O(n)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>不稳定</td>  </tr>  <tr>    <td rowspan="2">选择排序</td>    <td>直接选择</td>    <td>O(n²)</td>    <td>O(n²)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>不稳定</td>  </tr>  <tr>    <td>堆排序</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(1)</td>    <td>不稳定</td>  </tr>  <tr>    <td rowspan="2">狡猾排序</td>    <td>冒泡排序</td>    <td>O(n²)</td>    <td>O(n)</td>    <td>O(n²)</td>    <td>O(1)</td>    <td>稳定</td>  </tr>  <tr>    <td>快速排序</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(n²)</td>    <td>O(n)</td>    <td>不稳定</td>  </tr>  <tr>    <td colspan="2">归并排序</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(nlogn)</td>    <td>O(n)</td>    <td>稳定</td>  </tr>  <tr>    <td colspan="2">基数排序</td>    <td>O(d(r+n))</td>    <td>O(d(n+rd))</td>    <td>O(d(r+n))</td>    <td>O(rd+n)</td>    <td>稳定</td>  </tr></tbody></table><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-确定基准数"><a href="#1-确定基准数" class="headerlink" title="1. 确定基准数"></a>1. 确定基准数</h3><p>基准数就是选一个数作为标准,方便其他的数和它比较的一个数。<br>我们将数组的第一个数作为基准数，将大于基准数的放在基准数的右边，小于基准数的放在放在基准数的左边。</p><h3 id="2-确定数组的边界"><a href="#2-确定数组的边界" class="headerlink" title="2. 确定数组的边界"></a>2. 确定数组的边界</h3><p>定义两个变量指向序列的最左边(left)和最右边(right),让left自加直到找到大于基准数的时候停下，同理让right自减直到找到小于基准数的时候停下，将两个所对应的值进行交换。然后继续进行上步操作直到left&gt;=right。然后将left对应的值与基准数换位置。</p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>假设一个数组 arr = [6,1,2,7,9,3,4,5,10,8],对这个数组进行排序。<br><strong>初始状态</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>7</th><th>9</th><th>3</th><th>4</th><th>5</th><th>10</th><th>8</th></tr><tr><td><b>left</b></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><b>right</b></td></tr></tbody></table><p><strong>第一次<br>left和right在如下时候停下即（arr[left] &gt; 6 &amp;&amp; arr[right] &lt; 6）</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>7</th><th>9</th><th>3</th><th>4</th><th>5</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td><b>left</b></td><td></td><td></td><td></td><td><b>right</b></td><td></td><td></td></tr></tbody></table><p><strong>left和right所对应的数值交换位置</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>5</th><th>9</th><th>3</th><th>4</th><th>7</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td><b>left</b></td><td></td><td></td><td></td><td><b>right</b></td><td></td><td></td></tr></tbody></table>    <p><strong>第二次<br>与第一次同理可得</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>5</th><th>4</th><th>3</th><th>9</th><th>7</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td></td><td><b>left</b></td><td></td><td><b>right</b></td><td></td><td></td><td></td></tr></tbody></table>    <p><strong>第三次<br>left和right相遇了</strong></p><table><tbody><tr><th>6</th><th>1</th><th>2</th><th>5</th><th>4</th><th>3</th><th>9</th><th>7</th><th>10</th><th>8</th></tr><tr><td></td><td></td><td></td><td></td><td></td><td><b>right</b>--<b>left</b></td><td></td><td></td><td></td><td></td></tr></tbody></table>    <p><strong>与基准数交换,第一次排序就完成了</strong></p><table><tbody><tr><th>3</th><th>1</th><th>2</th><th>5</th><th>4</th><th>6</th><th>9</th><th>7</th><th>10</th><th>8</th></tr></tbody></table>## 代码实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick_sort</span>(<span class="params">arr,left, right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = left</span><br><span class="line">        <span class="keyword">var</span> j = right</span><br><span class="line">        <span class="keyword">var</span> z = arr[left]</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123; <span class="comment">// 如果数组只有一个元素</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j] &gt; z &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                j--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &lt;= z &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">var</span> n = arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = n</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[i]</span><br><span class="line">        arr[i] = z</span><br><span class="line">        </span><br><span class="line">        quick_sort(arr,left,i-<span class="number">1</span>) <span class="comment">// 将基准数的左边进行排序</span></span><br><span class="line">        quick_sort(arr,i+<span class="number">1</span>,right)<span class="comment">// 将基准数的右边进行排序</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><blockquote><p>1.用下标取基数，只有一个赋值操作，更快；<br>2.原地交换，不需要新建多余的数组容器存储被划分的数据，节省存储；</p></blockquote><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><blockquote><p>1.实际测试的时候，以第一个数为基准数的快排存在速度慢，数组超过10000条数据还会出现Maximum call stack size exceeded的情况</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;为什么选择快速排序？&lt;/li&gt;
&lt;li&gt;实现思路&lt;/li&gt;
&lt;li&gt;代码实现&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么选择快速排序？&quot;&gt;&lt;a href=&quot;#为什么选择快速排序？&quot; class=&quot;headerlink&quot; title=&quot;为</summary>
      
    
    
    
    <category term="排序算法" scheme="http://example.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="快排" scheme="http://example.com/tags/%E5%BF%AB%E6%8E%92/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js数组去重-ES6</title>
    <link href="http://example.com/2020/05/18/array-unique/"/>
    <id>http://example.com/2020/05/18/array-unique/</id>
    <published>2020-05-17T17:01:54.000Z</published>
    <updated>2020-12-14T03:52:27.009Z</updated>
    
    <content type="html"><![CDATA[<p>数组去重是面试经常会遇到的问题，解决的方案有很多，本篇着重通过es6提供的新的数据结构来解决。</p><ul><li>Map对象解决去重</li><li>Set对象解决去重</li></ul><h2 id="Map对象解决去重"><a href="#Map对象解决去重" class="headerlink" title="Map对象解决去重"></a>Map对象解决去重</h2><p>Map 对象保存<strong>键值对</strong>。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><h3 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a><strong>Map对象</strong></h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">clear</td><td align="center">删除所有的键/值对，没有返回值</td></tr><tr><td align="center">delete</td><td align="center">删除某个键，返回true。如果删除失败，返回false。</td></tr><tr><td align="center">forEach</td><td align="center">对每个元素执行指定操作。</td></tr><tr><td align="center">get</td><td align="center">返回Map对象key相对应的value值。</td></tr><tr><td align="center">has</td><td align="center">返回一个布尔值，表示某个键是否在当前Map对象之中。</td></tr><tr><td align="center">set</td><td align="center">给Map对象设置key/value键/值对。</td></tr></tbody></table><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> !res.has(a) &amp;&amp; res.set(a, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Array.filter()</strong></p><blockquote><p>创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p></blockquote><h2 id="Set对象解决去重"><a href="#Set对象解决去重" class="headerlink" title="Set对象解决去重"></a>Set对象解决去重</h2><p><strong>Set对象</strong>是值的集合,元素只会出现一次,即Set中的元素是<strong>唯一</strong>的.<br>通过Set()创建的是一个对象，可以使用<strong>点语法（…）</strong>或者是<strong>Array.from</strong>将其转化为数组，然后既可以使用数组处理函数了。</p><p><strong>Set对象</strong></p><blockquote><p><strong>语法</strong>：<br>new Set([iterable])<br><strong>参数</strong>：<br>iterable，如果传递一个可迭代对象(包括 Array，Map，Set，String，TypedArray，arguments 对象等等)，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。</p></blockquote><h3 id="数组去重-1"><a href="#数组去重-1" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Array.from()</strong></p><blockquote><p>用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组去重是面试经常会遇到的问题，解决的方案有很多，本篇着重通过es6提供的新的数据结构来解决。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map对象解决去重&lt;/li&gt;
&lt;li&gt;Set对象解决去重&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Map对象解决去重&quot;&gt;&lt;a href=&quot;#Map对象解决</summary>
      
    
    
    
    <category term="array" scheme="http://example.com/categories/array/"/>
    
    
    <category term="array" scheme="http://example.com/tags/array/"/>
    
    <category term="es6" scheme="http://example.com/tags/es6/"/>
    
  </entry>
  
</feed>
